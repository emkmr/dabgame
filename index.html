<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>DaB GAME</title>
<link rel="icon" type="image/png" href="assets/app-icon.png">
<link rel="apple-touch-icon" href="assets/app-icon.png">
<meta name="apple-mobile-web-app-title" content="DaB GAME">
<style>
@import url('https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@700&display=swap');

:root {
  --ground-color: #f7df7a;
  --ground-dark-color: #e0c25f;
}

body {
  margin: 0;
  padding: 0;
  background: linear-gradient(180deg, #f7e389 0%, #f7e389 15%, #e18448 15%, #e18448 85%, #f7e389 85%, #f7e389 100%);
  overflow: hidden;
  font-family: 'M PLUS Rounded 1c', sans-serif;
  touch-action: none;
  width: 100vw;
  height: 100vh;
}

#game-container {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

canvas {
  display: block;
  width: 100%;
  height: 100%;
}

#ui-layer {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
}

.hud {
  padding-top: max(20px, env(safe-area-inset-top) + 20px);
  padding-left: max(20px, env(safe-area-inset-left) + 20px);
  padding-right: max(20px, env(safe-area-inset-right) + 20px);
  padding-bottom: 20px;
  width: 100%;
  max-width: 420px;
  margin: 0 auto;
  box-sizing: border-box;
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  z-index: 100;
}

#score {
  font-size: 12px;
  color: rgba(51, 51, 51, 0.6);
  background: transparent;
  padding: 2px 0;
  font-weight: bold;
  letter-spacing: 0.08em;
  text-transform: uppercase;
}

#dist {
  font-size: 20px;
  color: #2a2620;
  font-weight: 700;
  text-shadow: none;
  background: none;
  border: none;
  padding: 0;
  margin-right: 6px;
}

#start-screen {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(255, 217, 230, 0.92);
  backdrop-filter: blur(12px);
  display: flex;
  justify-content: center;
  align-items: center;
  color: #333;
  z-index: 200;
  pointer-events: auto;
  padding: max(20px, env(safe-area-inset-top) + 10px) 20px max(30px, env(safe-area-inset-bottom) + 20px);
  box-sizing: border-box;
  overflow-y: auto;
}

.start-btn {
  padding: 18px 60px;
  font-size: 18px;
  font-weight: bold;
  background: #1f1b1a;
  color: white;
  border: none;
  cursor: pointer;
  border-radius: 50px;
  box-shadow: 0 10px 20px rgba(0,0,0,0.1);
  transition: transform 0.2s, box-shadow 0.2s;
  font-family: inherit;
}

.start-btn:active {
  transform: scale(0.95);
  box-shadow: 0 5px 10px rgba(0,0,0,0.1);
}

.overlay-card {
  width: min(360px, calc(100% - 40px));
  border-radius: 28px;
  border: 4px solid #2f4357;
  padding: 34px 26px 40px;
  background: #FFD9E6;
  box-shadow: 0 25px 40px rgba(0,0,0,0.2);
  text-align: center;
  color: #2c2c2c;
  display: flex;
  flex-direction: column;
  gap: 18px;
  max-height: calc(100vh - 120px);
  overflow-y: auto;
}

.overlay-video {
  width: 100%;
  max-height: 180px;
  border-radius: 24px;
  overflow: hidden;
  border: 3px solid #1f2d40;
  background: #000;
  box-sizing: border-box;
}

.overlay-video video {
  width: 100%;
  height: 180px;
  display: block;
  object-fit: cover;
}

.overlay-caption {
  font-size: 14px;
  letter-spacing: 0.3em;
  color: rgba(33, 33, 33, 0.8);
  margin-bottom: 18px;
}

.overlay-scene {
  border-radius: 24px;
  border: 3px solid #1f2d40;
  overflow: hidden;
  margin-bottom: 16px;
  background: #8cc0f4;
  box-shadow: inset 0 0 0 2px rgba(0,0,0,0.05);
  box-sizing: border-box;
}

.overlay-scene-sky {
  background: #8cc0f4;
  padding: 10px 18px 16px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
}

.overlay-scene-text {
  font-size: 16px;
  color: rgba(34,34,34,0.7);
  letter-spacing: 0.1em;
  margin: 0;
}

.overlay-hand {
  width: 54px;
  height: 54px;
}

.overlay-hand svg {
  width: 100%;
  height: 100%;
}

.overlay-scene-ground {
  background: linear-gradient(0deg, var(--ground-color) 0%, var(--ground-color) 100%);
  padding: 10px 18px 16px;
  position: relative;
  min-height: 70px;
  display: flex;
  align-items: flex-end;
}

.overlay-scene-character {
  width: 72px;
  height: 72px;
  object-fit: contain;
}

.overlay-sound {
  position: absolute;
  left: 20px;
  bottom: 16px;
  font-size: 18px;
  color: #2f2f2f;
}

.overlay-message {
  font-size: 32px;
  margin: 0;
  color: #2e2e2e;
}

.overlay-score-panel {
  display: none;
  align-items: center;
  justify-content: center;
  gap: 14px;
  margin: 18px 0;
  color: #c67b1d;
}

.overlay-score-panel.visible {
  display: flex;
}

.overlay-star {
  font-size: 26px;
}

.overlay-score-text {
  font-size: 16px;
  line-height: 1.2;
}

.overlay-score-value {
  font-size: 36px;
  font-weight: 700;
  display: block;
  color: #2f2b27;
}

.overlay-subtext {
  font-size: 14px;
  color: rgba(33, 33, 33, 0.8);
  margin-bottom: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.overlay-subtext-text {
  font-size: 14px;
}

.overlay-subtext-icon {
  width: 36px;
  height: 36px;
  object-fit: contain;
}
</style>
</head>

<body>
<div id="game-container">
  <canvas id="gameCanvas"></canvas>

  <div id="ui-layer">
    <div class="hud">
      <span id="score">SCORE: 0</span>
      <span id="dist">0</span>
    </div>
  </div>

  <div id="start-screen">
    <div class="overlay-card">
      <p class="overlay-caption">„Å¥„Çá„Çì„Å¥„Çá„ÇìSATOSHI</p>
      <div class="overlay-video" id="overlay-video">
        <video src="assets/intro.mov" autoplay muted loop playsinline></video>
      </div>
      <div class="overlay-scene" id="overlay-scene">
        <div class="overlay-scene-sky">
          <p class="overlay-scene-text">„Çø„ÉÉ„Éó„Åó„Å¶„Éó„É¨„Ç§</p>
          <div class="overlay-hand">
            <svg viewBox="0 0 64 64" fill="none" stroke="#555" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
              <path d="M20 26v-8a4 4 0 0 1 8 0v9"></path>
              <path d="M28 22v-6a4 4 0 0 1 8 0v10"></path>
              <path d="M36 24v-8a4 4 0 0 1 8 0v16"></path>
              <path d="M44 28v-6a4 4 0 0 1 8 0v20c0 8-6 14-14 14h-4"></path>
              <path d="M18 30c0 10 6 20 10 24"></path>
            </svg>
          </div>
        </div>
        <div class="overlay-scene-ground">
          <img src="assets/start_character.png" alt="runner" class="overlay-scene-character">
          <div class="overlay-sound">üîà</div>
        </div>
      </div>
      <h1 class="overlay-message" id="overlay-message"></h1>

      <div class="overlay-score-panel" id="overlay-score-panel">
        <span class="overlay-star">‚òÖ</span>
        <div class="overlay-score-text">
          <span>Score</span>
          <span class="overlay-score-value" id="overlay-score-value">0</span>
        </div>
        <span class="overlay-star">‚òÖ</span>
      </div>

      <p class="overlay-subtext" id="overlay-subtext"></p>
      <button class="start-btn" id="start-btn">PLAY GAME</button>
    </div>
  </div>
</div>

<script>
/**
 * Game Setup
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const startScreenEl = document.getElementById('start-screen');
const overlayMessageEl = document.getElementById('overlay-message');
const overlayScene = document.getElementById('overlay-scene');
const overlayVideo = document.getElementById('overlay-video');
const overlayScorePanel = document.getElementById('overlay-score-panel');
const overlayScoreValue = document.getElementById('overlay-score-value');
const overlaySubtextEl = document.getElementById('overlay-subtext');
const startBtn = document.getElementById('start-btn');

const COLORS = {
  sky: '#FFD9E6',
  ground: '#F7DF7A',
  groundDark: '#E0C25F',
  blockQ: '#FFB347',
  pipe: '#FF69B4',
  pipeDark: '#C71585',
  text: '#333333'
};

// ‚òÖ „Éû„ÉÉ„Éó„ÅÆÁ∏¶„Éû„ÇπÊï∞Ôºày=0..14 „Å®‰∏ÄËá¥Ôºâ
const ROWS = 15;
const SKULL_SCORE = 150;
const SKULL_JUMP_MULTIPLIER = 1.4;
const INVINCIBLE_DURATION = 480;
const SKY_DOG_INTERVAL = { min: 300, max: 640 };

const SKY_DOG_CONFIG = {
  baseSpeed: () => Math.max(1.8, view.w * 0.0025),
  yRange: () => ({
    min: view.h * 0.12,
    max: view.h * 0.25
  })
};

// ÁîªÈù¢ÔºàCSS„Éî„ÇØ„Çª„É´Âü∫Ê∫ñÔºâ
const view = { w: 0, h: 0, dpr: 1 };

// „Ç≤„Éº„É†ÂÆöÊï∞ÔºàÂàùÊúüÂÄ§Ôºâ
let TILE_SIZE = 40;
let GRAVITY = 0.6;
let JUMP_FORCE = -12;
let MOVE_SPEED = 6;

let gameState = {
  isRunning: false,
  score: 0,
  distance: 0,
  cameraX: 0
};

let jumpPressed = false;

/**
 * Resize Logic
 */
function getViewportSize() {
  // iOS Safari „ÅÆ„Ç¢„Éâ„É¨„Çπ„Éê„Éº‰º∏Á∏ÆÂØæÁ≠ñ
  const vv = window.visualViewport;
  const w = Math.floor(vv?.width ?? window.innerWidth);
  const h = Math.floor(vv?.height ?? window.innerHeight);
  return { w, h };
}

function calculateConstants() {
  // ‚òÖ ROWS (=15) „Å®‰∏ÄËá¥„Åï„Åõ„Å¶ tile „ÇíË®àÁÆó„Åô„ÇãÔºàÂ∫ä„ÅåË¶ã„Åà„Å™„ÅÑ„ÅÆ„Å´ÂΩì„Åü„ÇäÂà§ÂÆö„Å†„Åë„ÅÇ„ÇãÂïèÈ°å„ÅÆ‰∏ªÂõ†„ÇíÈô§ÂéªÔºâ
  TILE_SIZE = Math.max(24, Math.floor(view.h / ROWS));

  GRAVITY = TILE_SIZE * 0.03;
  JUMP_FORCE = -(TILE_SIZE * 0.55);
  MOVE_SPEED = TILE_SIZE * 0.15;
}

function resize() {
  const { w, h } = getViewportSize();
  view.w = w;
  view.h = h;
  view.dpr = window.devicePixelRatio || 1;

  // Ë¶ã„ÅüÁõÆ„Çµ„Ç§„Ç∫
  canvas.style.width = w + "px";
  canvas.style.height = h + "px";

  // ÂÆü„Éî„ÇØ„Çª„É´ÔºàÊèèÁîª„Éê„ÉÉ„Éï„Ç°Ôºâ
  canvas.width = Math.floor(w * view.dpr);
  canvas.height = Math.floor(h * view.dpr);

  // Â∫ßÊ®ôÁ≥ª„ÅØ CSS„Éî„ÇØ„Çª„É´„ÅßÊâ±„Åà„Çã„Çà„ÅÜ„Å´„Åô„Çã
  ctx.setTransform(view.dpr, 0, 0, view.dpr, 0, 0);

  if (!gameState.isRunning) {
    calculateConstants();
  }
}

window.addEventListener('resize', resize);
if (window.visualViewport) window.visualViewport.addEventListener('resize', resize);
resize();

/**
 * Drawing Functions
 */
function drawPlayer(ctx, x, y, frame) {
  const w = TILE_SIZE * 0.9;
  const h = TILE_SIZE * 1.5;

  ctx.save();
  ctx.translate(x, y);

  const ps = w / 12;

  if (isInvincible()) {
    ctx.save();
    const auraRadiusX = w * 0.9;
    const auraRadiusY = h * 0.8;
    const gradient = ctx.createRadialGradient(
      w / 2,
      h / 2,
      w * 0.2,
      w / 2,
      h / 2,
      Math.max(auraRadiusX, auraRadiusY)
    );
    gradient.addColorStop(0, 'rgba(255,255,255,0.7)');
    gradient.addColorStop(0.5, 'rgba(125,154,255,0.5)');
    gradient.addColorStop(1, 'rgba(191,98,255,0.35)');
    ctx.globalAlpha = 0.85;
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.ellipse(
      w / 2,
      h * 0.6,
      auraRadiusX,
      auraRadiusY,
      frame * 0.05,
      0,
      Math.PI * 2
    );
    ctx.fill();
    ctx.globalCompositeOperation = 'source-over';
    ctx.restore();
  }

  const c = {
    hair: '#222',
    skin: '#FCD',
    vest: '#2C3E50',
    shirt: '#FFF',
    pants: '#2C3E50'
  };

  const runFrame = Math.floor(frame / 5) % 4;
  let legOffsetL = 0;
  let legOffsetR = 0;

  if (!player.grounded) {
    legOffsetL = -1;
    legOffsetR = -2;
  } else {
    if (runFrame === 0) { legOffsetL = 0; legOffsetR = 0; }
    else if (runFrame === 1) { legOffsetL = -1; legOffsetR = 1; }
    else if (runFrame === 2) { legOffsetL = 0; legOffsetR = 0; }
    else { legOffsetL = 1; legOffsetR = -1; }
  }

  ctx.fillStyle = c.hair;
  ctx.fillRect(ps*2, ps*1, ps*8, ps*10);
  ctx.fillRect(ps*1, ps*3, ps*1, ps*8);

  ctx.fillStyle = c.pants;
  ctx.fillRect(ps*3, ps*11 + legOffsetL * ps, ps*2, ps*4);
  ctx.fillRect(ps*7, ps*11 + legOffsetR * ps, ps*2, ps*4);

  ctx.fillStyle = c.vest;
  ctx.fillRect(ps*3, ps*5, ps*6, ps*6);

  ctx.fillStyle = c.shirt;
  ctx.fillRect(ps*5, ps*5, ps*2, ps*2);
  if(runFrame % 2 === 0 || !player.grounded) {
    ctx.fillRect(ps*2, ps*5, ps*1, ps*4);
    ctx.fillRect(ps*9, ps*5, ps*1, ps*4);
  } else {
    ctx.fillRect(ps*2, ps*4, ps*1, ps*4);
    ctx.fillRect(ps*9, ps*6, ps*1, ps*4);
  }

  ctx.fillStyle = c.skin;
  ctx.fillRect(ps*2, ps*9 + (runFrame%2===0?0:-ps), ps*1, ps*1);
  ctx.fillRect(ps*9, ps*9 + (runFrame%2===0?0:ps), ps*1, ps*1);

  ctx.fillRect(ps*3, ps*1, ps*6, ps*4);

  ctx.fillStyle = c.hair;
  ctx.fillRect(ps*3, 0, ps*6, ps*1);
  ctx.fillRect(ps*3, ps*1, ps*1, ps*3);
  ctx.fillRect(ps*8, ps*1, ps*1, ps*3);
  ctx.fillRect(ps*3, ps*1, ps*2, ps*1);
  ctx.fillRect(ps*7, ps*1, ps*2, ps*1);

  ctx.fillStyle = '#000';
  ctx.fillRect(ps*4, ps*2, ps*1, ps*0.5);
  ctx.fillRect(ps*7, ps*2, ps*1, ps*0.5);
  ctx.fillRect(ps*5, ps*3.5, ps*2, ps*0.5);

  ctx.restore();
}

function drawBlock(ctx, x, y, type) {
  if (type === 1) { // Ground
    ctx.fillStyle = COLORS.ground;
    ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
    ctx.fillStyle = COLORS.groundDark;
    ctx.fillRect(x, y + TILE_SIZE - 4, TILE_SIZE, 4);
  } else if (type === 2) { // Scissors
    const cx = x + TILE_SIZE/2;
    const cy = y + TILE_SIZE/2;
    const s = TILE_SIZE * 0.7;

    ctx.save();
    ctx.translate(cx, cy);

    ctx.strokeStyle = '#444';
    ctx.lineWidth = s * 0.15;

    ctx.beginPath();
    ctx.arc(-s*0.25, s*0.4, s*0.2, 0, Math.PI * 2);
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(s*0.25, s*0.4, s*0.2, 0, Math.PI * 2);
    ctx.stroke();

    ctx.fillStyle = '#C0C0C0';
    ctx.beginPath();
    ctx.moveTo(-s*0.25, s*0.2);
    ctx.lineTo(0, -s*0.6);
    ctx.lineTo(s*0.05, s*0.2);
    ctx.moveTo(s*0.25, s*0.2);
    ctx.lineTo(0, -s*0.6);
    ctx.lineTo(-s*0.05, s*0.2);
    ctx.fill();

    ctx.fillStyle = '#666';
    ctx.beginPath();
    ctx.arc(0, 0, s*0.05, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  } else if (type === 3) { // Pipe
    ctx.fillStyle = COLORS.pipe;
    ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
    ctx.fillStyle = COLORS.pipeDark;
    ctx.fillRect(x + TILE_SIZE*0.1, y, TILE_SIZE*0.2, TILE_SIZE);
  } else if (type === 4) { // Skull
    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle = '#f9f6f2';
    const skullRadius = TILE_SIZE * 0.25;
    ctx.beginPath();
    ctx.arc(TILE_SIZE / 2, TILE_SIZE * 0.35, skullRadius, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#2f2f2f';
    const eyeSize = skullRadius * 0.6;
    const eyeY = TILE_SIZE * 0.3;
    ctx.fillRect(TILE_SIZE * 0.5 - skullRadius * 0.9, eyeY, eyeSize, eyeSize);
    ctx.fillRect(TILE_SIZE * 0.5 + skullRadius * 0.3, eyeY, eyeSize, eyeSize);
    ctx.fillRect((TILE_SIZE - skullRadius * 0.6) / 2, TILE_SIZE * 0.47, skullRadius * 0.6, skullRadius * 0.2);
    ctx.lineCap = 'round';
    ctx.lineWidth = TILE_SIZE * 0.07;
    ctx.strokeStyle = '#f9f6f2';
    ctx.beginPath();
    ctx.moveTo(TILE_SIZE * 0.25, TILE_SIZE * 0.75);
    ctx.lineTo(TILE_SIZE * 0.45, TILE_SIZE * 0.95);
    ctx.moveTo(TILE_SIZE * 0.45, TILE_SIZE * 0.75);
    ctx.lineTo(TILE_SIZE * 0.25, TILE_SIZE * 0.95);
    ctx.moveTo(TILE_SIZE * 0.55, TILE_SIZE * 0.75);
    ctx.lineTo(TILE_SIZE * 0.75, TILE_SIZE * 0.95);
    ctx.moveTo(TILE_SIZE * 0.75, TILE_SIZE * 0.75);
    ctx.lineTo(TILE_SIZE * 0.55, TILE_SIZE * 0.95);
    ctx.stroke();
    ctx.restore();
  }
}

function drawEnemy(ctx, x, y, frame) {
  const w = TILE_SIZE;
  const h = TILE_SIZE;

  ctx.fillStyle = '#8B4513';

  ctx.beginPath();
  ctx.arc(x + w/2, y + h/2, w/2, 0, Math.PI, true);
  ctx.fill();

  ctx.fillStyle = '#CD853F';
  ctx.fillRect(x + w*0.3, y + h/2, w*0.4, h/2);

  ctx.fillStyle = '#FFF';
  ctx.beginPath();
  ctx.arc(x + w*0.4, y + h*0.6, w*0.1, 0, Math.PI*2);
  ctx.arc(x + w*0.6, y + h*0.6, w*0.1, 0, Math.PI*2);
  ctx.fill();

  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.arc(x + w*0.42, y + h*0.6, w*0.04, 0, Math.PI*2);
  ctx.arc(x + w*0.62, y + h*0.6, w*0.04, 0, Math.PI*2);
  ctx.fill();

  if (Math.floor(frame / 10) % 2 === 0) {
    ctx.clearRect(x, y + h - 2, w, 2);
  }
}

function drawBackground(ctx) {
  ctx.fillStyle = COLORS.sky;
  ctx.fillRect(0, 0, view.w, view.h);

  ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';

  const cloud = (cx, cy, s) => {
    ctx.beginPath();
    ctx.arc(cx, cy, 30 * s, 0, Math.PI * 2);
    ctx.arc(cx + 40 * s, cy + 10 * s, 40 * s, 0, Math.PI * 2);
    ctx.arc(cx - 40 * s, cy + 10 * s, 40 * s, 0, Math.PI * 2);
    ctx.fill();
  };

  const offset = gameState.cameraX * 0.2;
  const w = view.w + 400;

  for(let i = 0; i < 3; i++) {
    let x = (200 + i * 500 - offset) % w;
    if (x < -200) x += w;
    cloud(x, 150 + (i%2)*50, 1.0 + (i%2)*0.2);
  }
}

function drawSkyDog(ctx, dog) {
  const bodyW = dog.size * 1.6;
  const bodyH = dog.size * 0.8;

  ctx.save();
  ctx.translate(dog.x + bodyW, dog.y);
  ctx.scale(-1, 1);

  ctx.fillStyle = '#6b4b2a';
  ctx.fillRect(0, bodyH * 0.2, bodyW, bodyH * 0.6);

  // head
  const headW = dog.size * 0.7;
  ctx.fillRect(bodyW - headW * 0.5, 0, headW, bodyH * 0.75);

  // ears
  ctx.fillRect(bodyW - headW * 0.2, -dog.size * 0.2, dog.size * 0.2, dog.size * 0.3);
  ctx.fillRect(bodyW - headW * 0.8, -dog.size * 0.2, dog.size * 0.2, dog.size * 0.3);

  // legs
  const legW = dog.size * 0.25;
  ctx.fillRect(bodyW * 0.1, bodyH * 0.8, legW, dog.size * 0.3);
  ctx.fillRect(bodyW * 0.9 - legW, bodyH * 0.8, legW, dog.size * 0.3);

  // tail
  ctx.beginPath();
  ctx.strokeStyle = '#6b4b2a';
  ctx.lineWidth = dog.size * 0.15;
  ctx.lineCap = 'round';
  ctx.moveTo(bodyW * 0.05, bodyH * 0.4);
  ctx.lineTo(-dog.size * 0.3, bodyH * 0.2);
  ctx.stroke();

  // collar accent
  ctx.fillStyle = '#f5d742';
  ctx.fillRect(bodyW - headW * 0.55, bodyH * 0.15, headW * 0.9, dog.size * 0.12);

  ctx.restore();
}

/**
 * Game Logic
 */
class Level {
  constructor() {
    this.map = {};
    this.enemies = [];
    this.generatedX = 0;
    this.groundY = 10;
    this.gapCooldown = 0;
    this.gapRemaining = 0;

    // ÂàùÂõûÁîüÊàêÁØÑÂõ≤„ÇíÂ∫É„ÅèÂèñ„ÇãÔºàÁîªÈù¢ÂπÖ„ÅÆ3ÂÄçÔºâ
    this.updateMap(view.w * 3);
  }

  updateMap(targetX) {
    // ÂÖàË™≠„ÅøÁØÑÂõ≤„ÇíÂ∫É„ÇÅ„Å´ (+50)
    const targetTileX = Math.ceil(targetX / TILE_SIZE) + 50;

    // ÁîüÊàê
    while (this.generatedX < targetTileX) {
      this.generateColumn(this.generatedX);
      this.generatedX++;
    }

    // „ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
    const deleteThreshold = Math.floor((gameState.cameraX - view.w) / TILE_SIZE);
    this.enemies = this.enemies.filter(e => e.x > gameState.cameraX - view.w);

    // Âè§„ÅÑ„Éû„ÉÉ„Éó„Éá„Éº„Çø„ÅÆÂâäÈô§ÔºàËªΩÈáèÂåñÔºâ
    if (this.generatedX % 100 === 0) {
      for (let x in this.map) {
        if (parseInt(x) < deleteThreshold) {
          delete this.map[x];
        }
      }
    }
  }

  generateColumn(x) {
    this.map[x] = [];
    // ÂàùÊúüÂåñ: ÂÖ®„Å¶„Çí0(Á©∫Ê∞ó)„Å´„Åô„Çã
    for(let y=0; y<ROWS; y++) this.map[x][y] = 0;

    // „Çπ„Çø„Éº„ÉàÂú∞ÁÇπ„ÄúÂÆâÂÖ®Âúè
    if (x < 30) {
      for(let y=this.groundY; y<ROWS; y++) this.map[x][y] = 1;
      return;
    }

    // „ÇØ„Éº„É´„ÉÄ„Ç¶„É≥Âá¶ÁêÜÔºàÁ©¥„ÅÆÁõ¥ÂæåÔºâ
    if (this.gapCooldown > 0) {
      this.gapCooldown--;
      for(let y=this.groundY; y<ROWS; y++) this.map[x][y] = 1;

      // „ÇØ„Éº„É´„ÉÄ„Ç¶„É≥‰∏≠„ÇÇ„Ç¢„Ç§„ÉÜ„É†Á≠â„ÅØÂá∫„Åó„Å¶OK
      this.generateObjects(x, this.groundY);
      return;
    }

    // Êñ∞„Åó„ÅÑÁ©¥„ÅÆÁîüÊàêÂà§ÂÆö
    if (this.gapRemaining <= 0 && Math.random() < 0.1) {
      const gapWidth = Math.floor(Math.random() * 2) + 2; // 2~3„Éû„Çπ
      this.gapRemaining = gapWidth;
      this.gapCooldown = gapWidth + 5; // „Ç∏„É£„É≥„ÉóÂæåÁùÄÂú∞„Çπ„Éö„Éº„ÇπÁ¢∫‰øù

      // Á©¥„ÅÆÂêë„Åì„ÅÜÂÅ¥„ÅÆÈ´ò„Åï„Çí„Åì„Åì„ÅßÊ±∫„ÇÅ„Å¶„Åä„Åè
      if (Math.random() < 0.5) {
        const diff = Math.floor(Math.random() * 3) - 1;
        this.groundY += diff;
        this.groundY = Math.max(7, Math.min(13, this.groundY));
      }
    }

    // Á©¥ÁîüÊàê‰∏≠
    if (this.gapRemaining > 0) {
      this.gapRemaining--;
      return; // Âú∞Èù¢ÁîüÊàê„Åó„Å™„ÅÑ
    }

    // Âú∞Èù¢„ÅÆÈ´ò„Åï„Çí„Åü„Åæ„Å´Â§â„Åà„Çã
    if (Math.random() < 0.05) {
      this.groundY += Math.random() > 0.5 ? 1 : -1;
      this.groundY = Math.max(7, Math.min(13, this.groundY));
    }

    // Âú∞Èù¢ÁîüÊàê
    for(let y=this.groundY; y<ROWS; y++) this.map[x][y] = 1;

    // „Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÈÖçÁΩÆ
    this.generateObjects(x, this.groundY);
  }

  generateObjects(x, groundY) {
    if (Math.random() < 0.05) {
      // Âú∞‰∏ä„ÅÆÈöúÂÆ≥Áâ©
      this.map[x][groundY-1] = Math.random() > 0.5 ? 3 : 2;
    } else if (Math.random() < 0.03) {
      this.map[x][groundY-1] = 4;
    } else if (Math.random() < 0.05) {
      // Á©∫‰∏≠„ÅÆË∂≥Â†¥
      this.map[x][groundY-4] = 2;
    }

    // Êïµ
    if (Math.random() < 0.03) {
      this.enemies.push({
        x: x * TILE_SIZE,
        y: (groundY - 1) * TILE_SIZE,
        active: true
      });
    }
  }

  draw(ctx, frame) {
    const startCol = Math.floor(gameState.cameraX / TILE_SIZE);
    // ÊèèÁîªÁØÑÂõ≤„ÇíÂ∞ë„ÅóÂ∫É„ÇÅ„Å´Âèñ„ÇãÔºà„ÉÅ„É©„Å§„ÅçÈò≤Ê≠¢Ôºâ
    const endCol = startCol + Math.ceil(view.w / TILE_SIZE) + 4;

    for (let x = startCol; x < endCol; x++) {
      if (!this.map[x]) continue;
      for (let y = 0; y < ROWS; y++) {
        const type = this.map[x][y];
        if (type && type !== 0) {
          drawBlock(ctx, x * TILE_SIZE - gameState.cameraX, y * TILE_SIZE, type);
        }
      }
    }

    this.enemies.forEach(e => {
      if (e.active && e.x > gameState.cameraX - TILE_SIZE && e.x < gameState.cameraX + view.w) {
        drawEnemy(ctx, e.x - gameState.cameraX, e.y, frame);
      }
    });
  }

  isSolid(x, y) {
    if (x < 0) return true;
    if (!this.map[x]) return false;
    if (y < 0 || y >= ROWS) return false;
    const tile = this.map[x][y];
    return tile !== undefined && tile !== 0 && tile !== 2 && tile !== 4;
  }
}

let player = {
  x: 0, y: 0, vx: 0, vy: 0, w: 0, h: 0, grounded: false, dead: false
};

let level;
let animationId;
let frameCount = 0;
let skyDogs = [];
let skyDogTimer = 0;
let invincibleTimer = 0;

function collectScissorAt(tileX, tileY) {
  if (!level) return false;
  const column = level.map[tileX];
  if (!column) return false;
  if (column[tileY] !== 2) return false;
  column[tileY] = 0;
  gameState.score += 50;
  document.getElementById('score').innerText = `SCORE: ${gameState.score}`;
  return true;
}

function collectScissorsInBounds() {
  const left = Math.floor((player.x + 4) / TILE_SIZE);
  const right = Math.floor((player.x + player.w - 4) / TILE_SIZE);
  const top = Math.floor((player.y + 4) / TILE_SIZE);
  const bottom = Math.floor((player.y + player.h - 4) / TILE_SIZE);

  for (let x = left; x <= right; x++) {
    for (let y = top; y <= bottom; y++) {
      collectScissorAt(x, y);
    }
  }
}

function handleSkullAt(tileX, tileY, prevBottom) {
  if (!level || player.dead) return;
  const column = level.map[tileX];
  if (!column) return;
  if (column[tileY] !== 4) return;

  const tileTop = tileY * TILE_SIZE;
  if (player.vy >= 0 && prevBottom <= tileTop + TILE_SIZE * 0.2) {
    column[tileY] = 0;
    gameState.score += SKULL_SCORE;
    document.getElementById('score').innerText = `SCORE: ${gameState.score}`;
    player.vy = JUMP_FORCE * SKULL_JUMP_MULTIPLIER;
  } else if (!isInvincible()) {
    die();
  }
}

function handleSkullsInBounds(prevBottom) {
  if (player.dead) return;
  const left = Math.floor((player.x + 4) / TILE_SIZE);
  const right = Math.floor((player.x + player.w - 4) / TILE_SIZE);
  const top = Math.floor((player.y + 4) / TILE_SIZE);
  const bottom = Math.floor((player.y + player.h - 4) / TILE_SIZE);

  for (let x = left; x <= right; x++) {
    for (let y = top; y <= bottom; y++) {
      handleSkullAt(x, y, prevBottom);
      if (player.dead) return;
    }
  }
}

function activateInvincibility() {
  invincibleTimer = INVINCIBLE_DURATION;
}

function isInvincible() {
  return invincibleTimer > 0;
}

function getSkyDogInterval() {
  const diff = SKY_DOG_INTERVAL.max - SKY_DOG_INTERVAL.min;
  return SKY_DOG_INTERVAL.min + Math.floor(Math.random() * diff);
}

function resetSkyDogs() {
  skyDogs = [];
  skyDogTimer = getSkyDogInterval();
}

function spawnSkyDog() {
  const size = Math.max(18, TILE_SIZE * 0.7);
  const { min, max } = SKY_DOG_CONFIG.yRange();
  const y = min + Math.random() * (max - min);
  skyDogs.push({
    x: view.w + size * 2,
    y,
    size,
    speed: SKY_DOG_CONFIG.baseSpeed() * (0.9 + Math.random() * 0.3)
  });
}

function updateSkyDogs() {
  skyDogTimer--;
  if (skyDogTimer <= 0) {
    spawnSkyDog();
    skyDogTimer = getSkyDogInterval();
  }
  const playerScreenX = player.x - gameState.cameraX;
  const playerScreenY = player.y;
  const playerScreenW = player.w;
  const playerScreenH = player.h;

  skyDogs.forEach(dog => {
    dog.x -= dog.speed;
    if (dog.collected) return;
    const dogW = dog.size * 1.6;
    const dogH = dog.size * 1.2;
    if (
      playerScreenX < dog.x + dogW &&
      playerScreenX + playerScreenW > dog.x &&
      playerScreenY < dog.y + dogH &&
      playerScreenY + playerScreenH > dog.y
    ) {
      activateInvincibility();
      dog.collected = true;
    }
  });
  skyDogs = skyDogs.filter(dog => !dog.collected && dog.x > -dog.size * 2);
}

function drawSkyDogs(ctx) {
  skyDogs.forEach(dog => drawSkyDog(ctx, dog));
}

function setOverlayState(state, scoreValue = 0) {
  if (state === 'start') {
    overlayScene.style.display = 'block';
    overlayVideo.style.display = 'block';
    overlayMessageEl.innerText = '';
    overlayMessageEl.style.display = 'none';
    overlaySubtextEl.innerHTML = '';
    overlaySubtextEl.style.display = 'none';
    overlayScorePanel.classList.remove('visible');
    startBtn.innerText = 'START!';
  } else if (state === 'gameover') {
    overlayScene.style.display = 'none';
    overlayVideo.style.display = 'none';
    overlayMessageEl.innerText = 'GAME OVER';
    overlayMessageEl.style.display = 'block';
    overlaySubtextEl.innerHTML = '<img src="assets/start_character.png" alt="character" class="overlay-subtext-icon"><span class="overlay-subtext-text">‰Ωï„ÇíË®Ä„Å£„Å¶„ÅÑ„Çã„ÅÆ„ÅãÂàÜ„Åã„Çä„Åæ„Åõ„Çì</span>';
    overlaySubtextEl.style.display = 'flex';
    overlayScoreValue.innerText = scoreValue;
    overlayScorePanel.classList.add('visible');
    startBtn.innerText = '„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÉÅ„É£„É¨„É≥„Ç∏„Åô„Çã';
  }
}

function init() {
  // „Ç≤„Éº„É†ÈñãÂßãÊôÇ: „Åì„Åì„ÅßÁîªÈù¢„Çµ„Ç§„Ç∫„Å´Âêà„Çè„Åõ„Å¶ÂÆöÊï∞„ÇíÁ¢∫ÂÆö„Åï„Åõ„Çã
  resize();
  calculateConstants();

  player.w = TILE_SIZE * 0.9;
  player.h = TILE_SIZE * 1.5;
  player.x = TILE_SIZE * 4;
  player.y = TILE_SIZE * 5;
  player.vx = MOVE_SPEED;
  player.vy = 0;
  player.dead = false;

  level = new Level();
  resetSkyDogs();
  invincibleTimer = 0;
  gameState.score = 0;
  gameState.distance = 0;
  gameState.cameraX = 0;
  gameState.isRunning = true;
  jumpPressed = false;

  startScreenEl.style.display = 'none';

  gameLoop();
}

function updatePhysics() {
  if (player.dead) {
    player.vy += GRAVITY;
    player.y += player.vy;
    return;
  }

  if (invincibleTimer > 0) invincibleTimer--;

  // „Éû„ÉÉ„ÉóÊõ¥Êñ∞: ÁîªÈù¢Â§ñ„ÇÇ‰ΩôË£ï„ÇíÊåÅ„Å£„Å¶ÁîüÊàê
  level.updateMap(player.x + view.w);

  player.vx = MOVE_SPEED;

  if (jumpPressed && player.grounded) {
    player.vy = JUMP_FORCE;
    player.grounded = false;
    jumpPressed = false;
  }

  player.vy += GRAVITY;
  const prevX = player.x;
  const prevY = player.y;
  player.x += player.vx;
  player.y += player.vy;

  gameState.distance = Math.floor(player.x / TILE_SIZE);
  document.getElementById('dist').innerText = `${gameState.distance}`;

  player.grounded = false;

  const getTile = (px, py) => ({
    x: Math.floor(px / TILE_SIZE),
    y: Math.floor(py / TILE_SIZE)
  });

  // Êé•Âú∞Âà§ÂÆö
  if (player.vy >= 0) {
    const bl = getTile(player.x + 5, player.y + player.h);
    const br = getTile(player.x + player.w - 5, player.y + player.h);

    if (level.isSolid(bl.x, bl.y) || level.isSolid(br.x, br.y)) {
      const blockTop = bl.y * TILE_SIZE;
      if (player.y + player.h <= blockTop + player.vy + TILE_SIZE/2) {
        player.y = blockTop - player.h;
        player.vy = 0;
        player.grounded = true;
      }
    }
  } else {
    const tl = getTile(player.x + 5, player.y);
    const tr = getTile(player.x + player.w - 5, player.y);
    if (level.isSolid(tl.x, tl.y) || level.isSolid(tr.x, tr.y)) {
      player.y = (tl.y + 1) * TILE_SIZE;
      player.vy = 0;
    }
  }

  // Ë°ùÁ™ÅÂà§ÂÆöÔºàÂè≥ÂÅ¥Ôºâ
  const tr = getTile(player.x + player.w, player.y + 5);
  const br = getTile(player.x + player.w, player.y + player.h - 5);

  const checkHit = (tile) => {
    const column = level.map[tile.x];
    if (!column) return false;

    const type = column[tile.y];
    if (type === undefined || type === 0) return false;

    if (type === 2) {
      collectScissorAt(tile.x, tile.y);
      return false;
    }

    if (!level.isSolid(tile.x, tile.y)) return false;

    if (type === 1 || type === 3) {
      // Âú∞Èù¢„ÉªÂúüÁÆ°„ÅØ„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº„Å´„Åó„Å™„ÅÑ„ÅåÂÖÉ„ÅÆ‰ΩçÁΩÆ„Å∏Êàª„Åô
      player.x = prevX;
      return false;
    }

    return true;
  };

  const hitTop = checkHit(tr);
  const hitBottom = checkHit(br);

  if ((hitTop || hitBottom) && !isInvincible()) {
    die();
  }

  const prevBottom = prevY + player.h;
  handleSkullsInBounds(prevBottom);
  collectScissorsInBounds();

  // ËêΩ‰∏ãÊ≠ª: „Éû„ÉÉ„ÉóÂ∫ï„ÅÆÂ∞ë„Åó‰∏ã„Åæ„ÅßËêΩ„Å°„Åü„ÇâÊ≠ª‰∫°
  const abyssY = ROWS * TILE_SIZE + TILE_SIZE * 2;
  if (player.y > abyssY) die();

  // „Ç´„É°„É©ËøΩÂæì
  const targetCamX = player.x - view.w * 0.2;
  gameState.cameraX = targetCamX;
  if (gameState.cameraX < 0) gameState.cameraX = 0;

  // Êïµ„Å®„ÅÆÂΩì„Åü„ÇäÂà§ÂÆö
  level.enemies.forEach(e => {
    if(!e.active) return;

    if (player.x < e.x + TILE_SIZE &&
        player.x + player.w > e.x &&
        player.y < e.y + TILE_SIZE &&
        player.y + player.h > e.y) {

      if (player.vy > 0 && player.y + player.h < e.y + TILE_SIZE * 0.6) {
        e.active = false;
        player.vy = JUMP_FORCE * 0.6;
        gameState.score += 100;
        document.getElementById('score').innerText = `SCORE: ${gameState.score}`;
      } else if (!isInvincible()) {
        die();
      } else {
        e.active = false;
        gameState.score += 100;
        document.getElementById('score').innerText = `SCORE: ${gameState.score}`;
      }
    }
  });

}

function die() {
  if(player.dead) return;

  player.dead = true;
  player.vy = JUMP_FORCE;
  player.vx = 0;
  const finalScore = gameState.score;

  setTimeout(() => {
    gameState.isRunning = false;
    setOverlayState('gameover', finalScore);
    startScreenEl.style.display = 'flex';
    gameState.score = 0;
    gameState.distance = 0;
    document.getElementById('score').innerText = 'SCORE: 0';
    document.getElementById('dist').innerText = '0';
  }, 1500);
}

function gameLoop() {
  if (!gameState.isRunning) return;

  ctx.clearRect(0, 0, view.w, view.h);

  drawBackground(ctx);
  updatePhysics();
  updateSkyDogs();
  drawSkyDogs(ctx);
  level.draw(ctx, frameCount);
  drawPlayer(ctx, player.x - gameState.cameraX, player.y, frameCount);

  frameCount++;
  animationId = requestAnimationFrame(gameLoop);
}

// „Éú„Çø„É≥„Ç§„Éô„É≥„Éà: „ÇØ„É™„ÉÉ„ÇØ„Å®„Çø„ÉÉ„ÉÅ‰∏°Êñπ„Å´ÂØæÂøú
startBtn.addEventListener('click', (e) => { e.preventDefault(); init(); });
startBtn.addEventListener('touchstart', (e) => { e.preventDefault(); init(); });
setOverlayState('start');

const container = document.getElementById('game-container');
const handleInput = (e) => {
  if(!gameState.isRunning) return;
  if(e.type !== 'mousedown') e.preventDefault(); // „Çø„ÉÉ„ÉÅÊôÇ„ÅÆÈáçË§á„Ç§„Éô„É≥„ÉàÈò≤Ê≠¢
  jumpPressed = true;
};
container.addEventListener('touchstart', handleInput, {passive: false});
container.addEventListener('mousedown', handleInput);

window.addEventListener('keydown', e => {
  if(e.code === 'Space' || e.key === 'ArrowUp') handleInput(e);
});
window.addEventListener('keyup', e => {
  if(e.code === 'Space' || e.key === 'ArrowUp') jumpPressed = false;
});

container.addEventListener('touchend', () => jumpPressed = false);
container.addEventListener('mouseup', () => jumpPressed = false);
</script>
</body>
</html>
