<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Modern Platformer</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@700&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            font-family: 'M PLUS Rounded 1c', sans-serif;
            touch-action: none;
            width: 100vw;
            height: 100vh;
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud {
            padding: 24px 20px;
            color: #333;
            font-weight: bold;
            font-size: 16px;
            display: flex;
            justify-content: space-between;
            z-index: 5;
        }

        .hud span {
            background: rgba(255, 255, 255, 0.6);
            padding: 6px 14px;
            border-radius: 20px;
            backdrop-filter: blur(4px);
        }

        /* Start Screen */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 240, 245, 0.9);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #333;
            z-index: 10;
            pointer-events: auto;
        }

        h1 {
            font-size: 32px;
            margin-bottom: 40px;
            color: #333;
            letter-spacing: 2px;
        }

        .instruction-box {
            display: flex;
            gap: 20px;
            margin-bottom: 40px;
        }

        .instruction-item {
            background: white;
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            text-align: center;
            width: 120px;
        }

        .icon {
            font-size: 32px;
            margin-bottom: 10px;
            display: block;
        }

        .label {
            font-size: 12px;
            color: #666;
            font-weight: bold;
        }

        .start-btn {
            padding: 18px 60px;
            font-size: 18px;
            font-weight: bold;
            background: #333;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 50px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
            transition: transform 0.2s, box-shadow 0.2s;
            font-family: inherit;
        }

        .start-btn:active {
            transform: scale(0.95);
            box-shadow: 0 5px 10px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div class="hud">
            <span id="score">SCORE: 0</span>
            <span id="time">TIME: 0</span>
        </div>
    </div>

    <div id="start-screen">
        <h1>RUN & JUMP</h1>
        
        <div class="instruction-box">
            <div class="instruction-item">
                <span class="icon">üëà</span>
                <span class="label">SLIDE TO MOVE</span>
            </div>
            <div class="instruction-item">
                <span class="icon">üëÜ</span>
                <span class="label">TAP TO JUMP</span>
            </div>
        </div>

        <button class="start-btn" id="start-btn">PLAY GAME</button>
    </div>
</div>

<script>
/**
 * Game Setup
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Colors
const COLORS = {
    sky: '#FFD9E6',       // ËñÑ„ÇÅ„ÅÆ„Éî„É≥„ÇØ
    ground: '#D4B856',    // ËêΩ„Å°ÁùÄ„ÅÑ„ÅüÈªÑËâ≤
    groundDark: '#B89C40',
    blockQ: '#FFB347',
    pipe: '#FF69B4',      // „Éî„É≥„ÇØ„ÅÆÂúüÁÆ°
    pipeDark: '#C71585',
    text: '#333333'
};

// Game Configuration
let TILE_SIZE = 30; // Â∞è„Åï„ÇÅ„Å´ÂàùÊúüÂåñ
let GRAVITY = 0.6;
let JUMP_FORCE = -12;
let MOVE_SPEED = 5;

// Game State
let gameState = {
    isRunning: false,
    score: 0,
    time: 0,
    cameraX: 0,
    offsetY: 0 // ÁîªÈù¢‰∏ä‰∏ã‰ΩçÁΩÆË™øÊï¥Áî®
};

// Inputs
const keys = { left: false, right: false, up: false };
const touchState = {
    active: false,
    originX: 0,
    currentX: 0,
    id: null
};

/**
 * Resize & Responsive Layout (ÂÜçË™øÊï¥Ê∏à„Åø)
 */
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // „Çµ„Ç§„Ç∫Ë™øÊï¥Ôºö1/16„Å†„Å®Â∞è„Åï„ÅÑ„ÄÅ1/14„Å†„Å®Â§ß„Åç„ÅÑ -> 1/15 „Å´Ë®≠ÂÆö
    TILE_SIZE = Math.floor(canvas.width / 15);

    // ‰∏ãÈôêË®≠ÂÆö
    if (TILE_SIZE < 20) TILE_SIZE = 20;

    // „Éë„É©„É°„Éº„Çø„ÅÆÂÜçË™øÊï¥
    GRAVITY = TILE_SIZE * 0.045;
    JUMP_FORCE = -(TILE_SIZE * 0.75);
    MOVE_SPEED = TILE_SIZE * 0.13;

    // Âú∞Èù¢‰ΩçÁΩÆ„ÅÆË™øÊï¥ÔºàÁÑ°ÈßÑ„Å™Á©∫ÁôΩ„ÅÆÂâäÈô§Ôºâ
    // „Éû„ÉÉ„Éó„ÅÆÈ´ò„Åï„ÅØ15„Éñ„É≠„ÉÉ„ÇØÂàÜ (Level„ÇØ„É©„ÇπÁîüÊàê„É≠„Ç∏„ÉÉ„ÇØÂèÇÁÖß)
    const mapTotalHeight = 15 * TILE_SIZE;
    
    // ÁîªÈù¢„ÅÆÈ´ò„Åï„Åã„Çâ„Éû„ÉÉ„Éó„ÅÆÈ´ò„Åï„ÇíÂºï„ÅÑ„ÅüÂàÜ„Çí„Ç™„Éï„Çª„ÉÉ„Éà„Å´„Åô„ÇãÔºà‰∏ãÁ´ØÂêà„Çè„ÅõÔºâ
    // „Åì„Çå„Å´„Çà„Çä„ÄÅÂú∞Èù¢„ÅåÁîªÈù¢‰∏ãÈÉ®„Å´ÈÖçÁΩÆ„Åï„Çå„ÄÅ‰∏äÈÉ®„ÅåÁ©∫„Å´„Å™„Çã
    gameState.offsetY = canvas.height - mapTotalHeight;
    
    // „ÇÇ„ÅóÁîªÈù¢„ÅÆÊñπ„ÅåÁã≠„ÅÑÂ†¥ÂêàÔºàÊ®™ÊåÅ„Å°„Å™„Å©Ôºâ„Åß„ÇÇ„ÄÅÂú∞Èù¢Ôºà‰∏ã„Åã„Çâ5„Éñ„É≠„ÉÉ„ÇØÔºâ„ÅåË¶ã„Åà„Çã„Çà„ÅÜ„Å´
    // ‰∏ãÁ´ØÂêà„Çè„Åõ„Å´„Åó„Å¶„Åä„Åë„Å∞Âü∫Êú¨ÁöÑ„Å´„ÅØOK
    // ÂæÆË™øÊï¥: Â∞ë„Åó„Å†„ÅëÊµÆ„Åã„Åõ„ÇãÔºàUI„Å®„Åã„Å∂„Çâ„Å™„ÅÑ„Çà„ÅÜ„Å´Ôºâ
    // gameState.offsetY -= 10; 
}
window.addEventListener('resize', resize);
resize();

/**
 * Drawing Functions
 */

function drawPlayer(ctx, x, y, dir, frame) {
    const w = TILE_SIZE * 0.9;
    const h = TILE_SIZE * 1.5;
    
    ctx.save();
    
    let drawX = x;
    let drawY = y;

    // Flip
    if (dir === -1) {
        ctx.translate(drawX + w, drawY);
        ctx.scale(-1, 1);
        drawX = 0;
        drawY = 0;
    } else {
        ctx.translate(drawX, drawY);
        drawX = 0;
        drawY = 0;
    }

    const ps = w / 12; // Pixel Size unit

    // Colors
    const c = {
        hair: '#222',
        skin: '#FCD',
        vest: '#2C3E50',
        shirt: '#FFF',
        pants: '#2C3E50'
    };

    const isWalk = frame % 20 < 10 && (keys.left || keys.right);

    // --- È´™„ÅÆÊØõÔºà„É≠„É≥„Ç∞Ôºâ ---
    ctx.fillStyle = c.hair;
    ctx.fillRect(ps*2, ps*1, ps*8, ps*10); 
    ctx.fillRect(ps*1, ps*3, ps*1, ps*8); 
    
    // Ë∂≥
    ctx.fillStyle = c.pants;
    if (isWalk) {
        ctx.fillRect(ps*3, ps*11, ps*2, ps*4); // L
        ctx.fillRect(ps*7, ps*11, ps*2, ps*3); // R (Up)
    } else {
        ctx.fillRect(ps*3, ps*11, ps*2, ps*4);
        ctx.fillRect(ps*7, ps*11, ps*2, ps*4);
    }

    // Body (Vest)
    ctx.fillStyle = c.vest;
    ctx.fillRect(ps*3, ps*5, ps*6, ps*6);

    // Arms/Shirt
    ctx.fillStyle = c.shirt;
    ctx.fillRect(ps*5, ps*5, ps*2, ps*2); // V-neck
    ctx.fillRect(ps*2, ps*5, ps*1, ps*4); // L Arm
    ctx.fillRect(ps*9, ps*5, ps*1, ps*4); // R Arm

    // Hands
    ctx.fillStyle = c.skin;
    ctx.fillRect(ps*2, ps*9, ps*1, ps*1);
    ctx.fillRect(ps*9, ps*9, ps*1, ps*1);

    // Face
    ctx.fillRect(ps*3, ps*1, ps*6, ps*4);

    // Hair Front
    ctx.fillStyle = c.hair;
    ctx.fillRect(ps*3, 0, ps*6, ps*1);
    ctx.fillRect(ps*3, ps*1, ps*1, ps*3);
    ctx.fillRect(ps*8, ps*1, ps*1, ps*3);
    ctx.fillRect(ps*3, ps*1, ps*2, ps*1);
    ctx.fillRect(ps*7, ps*1, ps*2, ps*1);

    // Face details
    ctx.fillStyle = '#000';
    ctx.fillRect(ps*4, ps*2, ps*1, ps*0.5); // Eye L
    ctx.fillRect(ps*7, ps*2, ps*1, ps*0.5); // Eye R
    ctx.fillRect(ps*5, ps*3.5, ps*2, ps*0.5); // Mouth

    ctx.restore();
}

function drawBlock(ctx, x, y, type) {
    if (type === 1) { // Ground (Yellow)
        ctx.fillStyle = COLORS.ground;
        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
        ctx.fillStyle = COLORS.groundDark;
        ctx.fillRect(x, y + TILE_SIZE - 4, TILE_SIZE, 4); 
    } else if (type === 2) { // Lucky Block
        ctx.fillStyle = COLORS.blockQ;
        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
        ctx.fillStyle = '#FFF';
        ctx.font = `bold ${TILE_SIZE * 0.6}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.fillText('?', x + TILE_SIZE/2, y + TILE_SIZE * 0.7);
    } else if (type === 3) { // Pipe (Pink)
        ctx.fillStyle = COLORS.pipe;
        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
        ctx.fillStyle = COLORS.pipeDark;
        ctx.fillRect(x + TILE_SIZE*0.1, y, TILE_SIZE*0.2, TILE_SIZE);
    }
}

function drawEnemy(ctx, x, y, frame) {
    const w = TILE_SIZE;
    const h = TILE_SIZE;
    
    ctx.fillStyle = '#8B4513';
    
    // Simple Mushroom Shape
    ctx.beginPath();
    ctx.arc(x + w/2, y + h/2, w/2, 0, Math.PI, true);
    ctx.fill();
    
    ctx.fillStyle = '#CD853F'; // Stem
    ctx.fillRect(x + w*0.3, y + h/2, w*0.4, h/2);

    // Eyes
    ctx.fillStyle = '#FFF';
    ctx.beginPath();
    ctx.arc(x + w*0.4, y + h*0.6, w*0.1, 0, Math.PI*2);
    ctx.arc(x + w*0.6, y + h*0.6, w*0.1, 0, Math.PI*2);
    ctx.fill();
    
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(x + w*0.42, y + h*0.6, w*0.04, 0, Math.PI*2);
    ctx.arc(x + w*0.62, y + h*0.6, w*0.04, 0, Math.PI*2);
    ctx.fill();

    if (Math.floor(frame / 10) % 2 === 0) {
        ctx.clearRect(x, y + h - 2, w, 2);
    }
}

function drawBackground(ctx) {
    ctx.fillStyle = COLORS.sky;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
    
    const cloud = (cx, cy, s) => {
        ctx.beginPath();
        ctx.arc(cx, cy, 30 * s, 0, Math.PI * 2);
        ctx.arc(cx + 40 * s, cy + 10 * s, 40 * s, 0, Math.PI * 2);
        ctx.arc(cx - 40 * s, cy + 10 * s, 40 * s, 0, Math.PI * 2);
        ctx.fill();
    };

    const offset = gameState.cameraX * 0.2;
    // Èõ≤„ÅÆ„Çµ„Ç§„Ç∫„ÇÇÂ∞ë„ÅóË™øÊï¥
    const s = 0.75; 
    cloud(200 - offset % (canvas.width + 400), 100, 0.8 * s);
    cloud(800 - offset % (canvas.width + 400), 150, 1.0 * s);
    cloud(1400 - offset % (canvas.width + 400), 80, 0.6 * s);
}

/**
 * Game Logic
 */
class Level {
    constructor() {
        this.map = [];
        this.enemies = [];
        this.width = 300; // „Çπ„ÉÜ„Éº„Ç∏„ÇíÈï∑„Åè
        this.height = 15; // ÊèèÁîª„É´„Éº„Éó„Å´Âêà„Çè„Åõ„Å¶15„Å´‰øÆÊ≠£ÔºàË´ñÁêÜÁöÑ„Å´„ÅØÔºâ
        this.generate();
    }

    generate() {
        const groundY = 10;

        for (let x = 0; x < this.width; x++) {
            this.map[x] = [];
            for (let y = 0; y < 15; y++) {
                if (y >= groundY) {
                    // Á©¥„ÅÆÈÖçÁΩÆ
                    if ((x > 30 && x < 35) || (x > 90 && x < 94) || (x > 150 && x < 155)) {
                        this.map[x][y] = 0;
                    } else {
                        this.map[x][y] = 1;
                    }
                } else {
                    this.map[x][y] = 0;
                }
            }
        }

        const set = (x, y, t) => { if(this.map[x]) this.map[x][y] = t; };

        // „Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÈÖçÁΩÆ
        set(15, groundY - 4, 2);
        set(20, groundY - 4, 1); set(21, groundY - 4, 1); set(22, groundY - 4, 2);
        
        set(45, groundY - 1, 3); set(45, groundY - 2, 3);
        set(65, groundY - 1, 3); set(65, groundY - 2, 3); set(65, groundY - 3, 3);

        for(let i=0; i<5; i++) {
            for(let j=0; j<=i; j++) {
                set(110+i, groundY - 1 - j, 1);
            }
        }

        // Êïµ„ÅÆÈÖçÁΩÆ
        const enemyPositions = [35, 60, 85, 130, 180, 220]; 
        
        enemyPositions.forEach(posX => {
             this.enemies.push({
                 x: posX * TILE_SIZE, 
                 y: 0, 
                 active: true, 
                 vx: -0.7
             });
        });
    }

    update() {
        this.enemies.forEach(e => {
            if (!e.active) return;
            const bx = Math.floor(e.x / TILE_SIZE);
            const by = 9;
            e.y = by * TILE_SIZE;
            
            if (e.x < gameState.cameraX + canvas.width + 100 && e.x > gameState.cameraX - 100) {
                 e.x += e.vx * (TILE_SIZE / 32);
            }
        });
    }

    draw(ctx, frame) {
        const startCol = Math.floor(gameState.cameraX / TILE_SIZE);
        const endCol = startCol + Math.ceil(canvas.width / TILE_SIZE) + 1;

        for (let x = startCol; x < endCol; x++) {
            if (!this.map[x]) continue;
            for (let y = 0; y < 15; y++) {
                const type = this.map[x][y];
                if (type !== 0) {
                    drawBlock(ctx, x * TILE_SIZE - gameState.cameraX, y * TILE_SIZE, type);
                }
            }
        }

        this.enemies.forEach(e => {
            if (e.active) {
                if (e.x > gameState.cameraX - TILE_SIZE && e.x < gameState.cameraX + canvas.width) {
                    drawEnemy(ctx, e.x - gameState.cameraX, e.y, frame);
                }
            }
        });
    }

    isSolid(x, y) {
        if (x < 0 || x >= this.width) return false;
        if (y < 0 || y >= 15) return false;
        return this.map[x][y] !== 0;
    }
}

let player = {
    x: 100,
    y: 100,
    vx: 0,
    vy: 0,
    w: 0, 
    h: 0,
    grounded: false,
    dir: 1,
    dead: false
};

let level;
let animationId;
let frameCount = 0;

function init() {
    resize();
    player.w = TILE_SIZE * 0.9;
    player.h = TILE_SIZE * 1.5;
    player.x = TILE_SIZE * 2;
    player.y = TILE_SIZE * 5;
    player.vx = 0;
    player.vy = 0;
    player.dead = false;
    
    level = new Level();
    gameState.score = 0;
    gameState.time = 0;
    gameState.cameraX = 0;
    gameState.isRunning = true;

    document.getElementById('start-screen').style.display = 'none';
    
    if(window.timerInt) clearInterval(window.timerInt);
    window.timerInt = setInterval(() => {
        if(gameState.isRunning && !player.dead) {
            gameState.time++;
            document.getElementById('time').innerText = `TIME: ${gameState.time}`;
        }
    }, 1000);

    gameLoop();
}

function updatePhysics() {
    if (player.dead) {
        player.vy += GRAVITY;
        player.y += player.vy;
        return;
    }

    if (keys.left) {
        player.vx = -MOVE_SPEED;
        player.dir = -1;
    } else if (keys.right) {
        player.vx = MOVE_SPEED;
        player.dir = 1;
    } else {
        player.vx = 0;
    }

    if (keys.up && player.grounded) {
        player.vy = JUMP_FORCE;
        player.grounded = false;
    }

    player.vy += GRAVITY;
    player.x += player.vx;
    player.y += player.vy;

    player.grounded = false;
    
    const getTile = (px, py) => ({
        x: Math.floor(px / TILE_SIZE),
        y: Math.floor(py / TILE_SIZE)
    });

    if (player.vy >= 0) {
        const bl = getTile(player.x + player.w * 0.2, player.y + player.h);
        const br = getTile(player.x + player.w * 0.8, player.y + player.h);
        
        if (level.isSolid(bl.x, bl.y) || level.isSolid(br.x, br.y)) {
            const blockTop = bl.y * TILE_SIZE;
            if (player.y + player.h <= blockTop + player.vy + TILE_SIZE/2) {
                player.y = blockTop - player.h;
                player.vy = 0;
                player.grounded = true;
            }
        }
    }

    if (player.vy < 0) {
        const tl = getTile(player.x + player.w * 0.2, player.y);
        const tr = getTile(player.x + player.w * 0.8, player.y);
        if (level.isSolid(tl.x, tl.y) || level.isSolid(tr.x, tr.y)) {
            player.y = (tl.y + 1) * TILE_SIZE;
            player.vy = 0;
        }
    }

    if (player.x < 0) player.x = 0;
    if (player.y > canvas.height + 100) die();

    const targetCamX = player.x - canvas.width * 0.2;
    gameState.cameraX += (targetCamX - gameState.cameraX) * 0.1;
    if (gameState.cameraX < 0) gameState.cameraX = 0;

    level.enemies.forEach(e => {
        if(!e.active) return;
        const hitMargin = TILE_SIZE * 0.25;
        
        if (player.x + hitMargin < e.x + TILE_SIZE - hitMargin &&
            player.x + player.w - hitMargin > e.x + hitMargin &&
            player.y < e.y + TILE_SIZE &&
            player.y + player.h > e.y + hitMargin) {
            
            if (player.vy > 0 && player.y + player.h < e.y + TILE_SIZE * 0.6) {
                e.active = false;
                player.vy = JUMP_FORCE * 0.5;
                gameState.score += 100;
                document.getElementById('score').innerText = `SCORE: ${gameState.score}`;
            } else {
                die();
            }
        }
    });
}

function die() {
    if(player.dead) return;
    player.dead = true;
    player.vy = JUMP_FORCE;
    setTimeout(() => {
        gameState.isRunning = false;
        document.querySelector('#start-screen h1').innerText = "GAME OVER";
        document.querySelector('#start-btn').innerText = "TRY AGAIN";
        document.getElementById('start-screen').style.display = 'flex';
    }, 2000);
}

function gameLoop() {
    if (!gameState.isRunning) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    drawBackground(ctx);

    // ÁîªÈù¢ÂÖ®‰Ωì„Çí‰∏ãÂØÑ„Åõ„Å´„Åô„ÇãÔºàÁ©∫ÁôΩÂâäÈô§Ôºâ
    ctx.save();
    ctx.translate(0, gameState.offsetY);

    updatePhysics();
    level.update();
    level.draw(ctx, frameCount);
    drawPlayer(ctx, player.x - gameState.cameraX, player.y, player.dir, frameCount);
    
    ctx.restore();

    // UI„ÅØ„Ç™„Éï„Çª„ÉÉ„Éà„ÅÆÂΩ±Èüø„ÇíÂèó„Åë„Å™„ÅÑ‰ΩçÁΩÆ„Å´ÊèèÁîª
    if (touchState.active) {
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
        ctx.lineWidth = 2;
        ctx.arc(touchState.originX, touchState.originY, 40, 0, Math.PI*2);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.fillStyle = 'rgba(255,255,255,0.8)';
        ctx.arc(touchState.currentX, touchState.currentY, 20, 0, Math.PI*2);
        ctx.fill();
    }

    frameCount++;
    animationId = requestAnimationFrame(gameLoop);
}

/**
 * Event Listeners
 */
document.getElementById('start-btn').addEventListener('click', init);

const container = document.getElementById('game-container');

container.addEventListener('touchstart', (e) => {
    if(!gameState.isRunning) return;
    e.preventDefault();
    
    for (let i=0; i<e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        if (t.clientX < window.innerWidth / 2) {
            if (!touchState.active) {
                touchState.active = true;
                touchState.id = t.identifier;
                touchState.originX = t.clientX;
                touchState.originY = t.clientY;
                touchState.currentX = t.clientX;
            }
        } else {
            keys.up = true;
        }
    }
}, {passive: false});

container.addEventListener('touchmove', (e) => {
    if(!gameState.isRunning) return;
    e.preventDefault();

    for (let i=0; i<e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        if (touchState.active && t.identifier === touchState.id) {
            touchState.currentX = t.clientX;
            touchState.currentY = t.clientY;
            
            const dx = t.clientX - touchState.originX;
            if (dx < -10) { keys.left = true; keys.right = false; }
            else if (dx > 10) { keys.right = true; keys.left = false; }
            else { keys.left = false; keys.right = false; }
        }
    }
}, {passive: false});

container.addEventListener('touchend', (e) => {
    if(!gameState.isRunning) return;
    e.preventDefault();
    for (let i=0; i<e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        if (touchState.active && t.identifier === touchState.id) {
            touchState.active = false;
            keys.left = false;
            keys.right = false;
        } else {
            keys.up = false;
        }
    }
}, {passive: false});

window.addEventListener('keydown', e => {
    if(e.key === 'ArrowLeft') keys.left = true;
    if(e.key === 'ArrowRight') keys.right = true;
    if(e.key === 'ArrowUp' || e.code === 'Space') keys.up = true;
});
window.addEventListener('keyup', e => {
    if(e.key === 'ArrowLeft') keys.left = false;
    if(e.key === 'ArrowRight') keys.right = false;
    if(e.key === 'ArrowUp' || e.code === 'Space') keys.up = false;
});

</script>
</body>
</html>