<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>Infinite Runner Fixed</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@700&display=swap');

body {
  margin: 0;
  padding: 0;
  background-color: #000;
  overflow: hidden;
  font-family: 'M PLUS Rounded 1c', sans-serif;
  touch-action: none;
  width: 100vw;
  height: 100vh;
}

#game-container {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

canvas {
  display: block;
  width: 100%;
  height: 100%;
}

#ui-layer {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
}

.hud {
  padding-top: max(20px, env(safe-area-inset-top) + 20px);
  padding-left: max(20px, env(safe-area-inset-left) + 20px);
  padding-right: max(20px, env(safe-area-inset-right) + 20px);
  padding-bottom: 20px;
  width: 100%;
  box-sizing: border-box;
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  z-index: 100;
}

#score {
  font-size: 16px;
  color: #555;
  background: rgba(255, 255, 255, 0.6);
  padding: 6px 14px;
  border-radius: 20px;
  font-weight: bold;
}

#dist {
  font-size: 36px;
  color: #333;
  font-weight: 800;
  text-shadow: 2px 2px 0px rgba(255,255,255,0.5);
  background: none;
  border: none;
  box-shadow: none;
  padding: 0;
  margin-right: 10px;
}

#start-screen {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(255, 240, 245, 0.9);
  backdrop-filter: blur(10px);
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  color: #333;
  z-index: 200;
  pointer-events: auto;
}

h1 {
  font-size: 32px;
  margin-bottom: 40px;
  color: #333;
  letter-spacing: 2px;
}

.instruction-box {
  display: flex;
  gap: 20px;
  margin-bottom: 40px;
}

.instruction-item {
  background: white;
  padding: 20px;
  border-radius: 16px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.05);
  text-align: center;
  width: 120px;
}

.icon {
  font-size: 32px;
  margin-bottom: 10px;
  display: block;
}

.label {
  font-size: 12px;
  color: #666;
  font-weight: bold;
}

.start-btn {
  padding: 18px 60px;
  font-size: 18px;
  font-weight: bold;
  background: #333;
  color: white;
  border: none;
  cursor: pointer;
  border-radius: 50px;
  box-shadow: 0 10px 20px rgba(0,0,0,0.1);
  transition: transform 0.2s, box-shadow 0.2s;
  font-family: inherit;
}

.start-btn:active {
  transform: scale(0.95);
  box-shadow: 0 5px 10px rgba(0,0,0,0.1);
}
</style>
</head>

<body>
<div id="game-container">
  <canvas id="gameCanvas"></canvas>

  <div id="ui-layer">
    <div class="hud">
      <span id="score">SCORE: 0</span>
      <span id="dist">0</span>
    </div>
  </div>

  <div id="start-screen">
    <h1>RUN & JUMP</h1>

    <div class="instruction-box">
      <div class="instruction-item">
        <span class="icon">ğŸ‘†</span>
        <span class="label">TAP TO JUMP</span>
      </div>
    </div>

    <button class="start-btn" id="start-btn">PLAY GAME</button>
  </div>
</div>

<script>
/**
 * Game Setup
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const COLORS = {
  sky: '#FFD9E6',
  ground: '#D4B856',
  groundDark: '#B89C40',
  blockQ: '#FFB347',
  pipe: '#FF69B4',
  pipeDark: '#C71585',
  text: '#333333'
};

// â˜… ãƒãƒƒãƒ—ã®ç¸¦ãƒã‚¹æ•°ï¼ˆy=0..14 ã¨ä¸€è‡´ï¼‰
const ROWS = 15;

// ç”»é¢ï¼ˆCSSãƒ”ã‚¯ã‚»ãƒ«åŸºæº–ï¼‰
const view = { w: 0, h: 0, dpr: 1 };

// ã‚²ãƒ¼ãƒ å®šæ•°ï¼ˆåˆæœŸå€¤ï¼‰
let TILE_SIZE = 40;
let GRAVITY = 0.6;
let JUMP_FORCE = -12;
let MOVE_SPEED = 6;

let gameState = {
  isRunning: false,
  score: 0,
  distance: 0,
  cameraX: 0
};

let jumpPressed = false;

/**
 * Resize Logic
 */
function getViewportSize() {
  // iOS Safari ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒãƒ¼ä¼¸ç¸®å¯¾ç­–
  const vv = window.visualViewport;
  const w = Math.floor(vv?.width ?? window.innerWidth);
  const h = Math.floor(vv?.height ?? window.innerHeight);
  return { w, h };
}

function calculateConstants() {
  // â˜… ROWS (=15) ã¨ä¸€è‡´ã•ã›ã¦ tile ã‚’è¨ˆç®—ã™ã‚‹ï¼ˆåºŠãŒè¦‹ãˆãªã„ã®ã«å½“ãŸã‚Šåˆ¤å®šã ã‘ã‚ã‚‹å•é¡Œã®ä¸»å› ã‚’é™¤å»ï¼‰
  TILE_SIZE = Math.max(24, Math.floor(view.h / ROWS));

  GRAVITY = TILE_SIZE * 0.03;
  JUMP_FORCE = -(TILE_SIZE * 0.55);
  MOVE_SPEED = TILE_SIZE * 0.15;
}

function resize() {
  const { w, h } = getViewportSize();
  view.w = w;
  view.h = h;
  view.dpr = window.devicePixelRatio || 1;

  // è¦‹ãŸç›®ã‚µã‚¤ã‚º
  canvas.style.width = w + "px";
  canvas.style.height = h + "px";

  // å®Ÿãƒ”ã‚¯ã‚»ãƒ«ï¼ˆæç”»ãƒãƒƒãƒ•ã‚¡ï¼‰
  canvas.width = Math.floor(w * view.dpr);
  canvas.height = Math.floor(h * view.dpr);

  // åº§æ¨™ç³»ã¯ CSSãƒ”ã‚¯ã‚»ãƒ«ã§æ‰±ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹
  ctx.setTransform(view.dpr, 0, 0, view.dpr, 0, 0);

  if (!gameState.isRunning) {
    calculateConstants();
  }
}

window.addEventListener('resize', resize);
if (window.visualViewport) window.visualViewport.addEventListener('resize', resize);
resize();

/**
 * Drawing Functions
 */
function drawPlayer(ctx, x, y, frame) {
  const w = TILE_SIZE * 0.9;
  const h = TILE_SIZE * 1.5;

  ctx.save();
  ctx.translate(x, y);

  const ps = w / 12;

  const c = {
    hair: '#222',
    skin: '#FCD',
    vest: '#2C3E50',
    shirt: '#FFF',
    pants: '#2C3E50'
  };

  const runFrame = Math.floor(frame / 5) % 4;
  let legOffsetL = 0;
  let legOffsetR = 0;

  if (!player.grounded) {
    legOffsetL = -1;
    legOffsetR = -2;
  } else {
    if (runFrame === 0) { legOffsetL = 0; legOffsetR = 0; }
    else if (runFrame === 1) { legOffsetL = -1; legOffsetR = 1; }
    else if (runFrame === 2) { legOffsetL = 0; legOffsetR = 0; }
    else { legOffsetL = 1; legOffsetR = -1; }
  }

  ctx.fillStyle = c.hair;
  ctx.fillRect(ps*2, ps*1, ps*8, ps*10);
  ctx.fillRect(ps*1, ps*3, ps*1, ps*8);

  ctx.fillStyle = c.pants;
  ctx.fillRect(ps*3, ps*11 + legOffsetL * ps, ps*2, ps*4);
  ctx.fillRect(ps*7, ps*11 + legOffsetR * ps, ps*2, ps*4);

  ctx.fillStyle = c.vest;
  ctx.fillRect(ps*3, ps*5, ps*6, ps*6);

  ctx.fillStyle = c.shirt;
  ctx.fillRect(ps*5, ps*5, ps*2, ps*2);
  if(runFrame % 2 === 0 || !player.grounded) {
    ctx.fillRect(ps*2, ps*5, ps*1, ps*4);
    ctx.fillRect(ps*9, ps*5, ps*1, ps*4);
  } else {
    ctx.fillRect(ps*2, ps*4, ps*1, ps*4);
    ctx.fillRect(ps*9, ps*6, ps*1, ps*4);
  }

  ctx.fillStyle = c.skin;
  ctx.fillRect(ps*2, ps*9 + (runFrame%2===0?0:-ps), ps*1, ps*1);
  ctx.fillRect(ps*9, ps*9 + (runFrame%2===0?0:ps), ps*1, ps*1);

  ctx.fillRect(ps*3, ps*1, ps*6, ps*4);

  ctx.fillStyle = c.hair;
  ctx.fillRect(ps*3, 0, ps*6, ps*1);
  ctx.fillRect(ps*3, ps*1, ps*1, ps*3);
  ctx.fillRect(ps*8, ps*1, ps*1, ps*3);
  ctx.fillRect(ps*3, ps*1, ps*2, ps*1);
  ctx.fillRect(ps*7, ps*1, ps*2, ps*1);

  ctx.fillStyle = '#000';
  ctx.fillRect(ps*4, ps*2, ps*1, ps*0.5);
  ctx.fillRect(ps*7, ps*2, ps*1, ps*0.5);
  ctx.fillRect(ps*5, ps*3.5, ps*2, ps*0.5);

  ctx.restore();
}

function drawBlock(ctx, x, y, type) {
  if (type === 1) { // Ground
    ctx.fillStyle = COLORS.ground;
    ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
    ctx.fillStyle = COLORS.groundDark;
    ctx.fillRect(x, y + TILE_SIZE - 4, TILE_SIZE, 4);
  } else if (type === 2) { // Scissors
    const cx = x + TILE_SIZE/2;
    const cy = y + TILE_SIZE/2;
    const s = TILE_SIZE * 0.7;

    ctx.save();
    ctx.translate(cx, cy);

    ctx.strokeStyle = '#444';
    ctx.lineWidth = s * 0.15;

    ctx.beginPath();
    ctx.arc(-s*0.25, s*0.4, s*0.2, 0, Math.PI * 2);
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(s*0.25, s*0.4, s*0.2, 0, Math.PI * 2);
    ctx.stroke();

    ctx.fillStyle = '#C0C0C0';
    ctx.beginPath();
    ctx.moveTo(-s*0.25, s*0.2);
    ctx.lineTo(0, -s*0.6);
    ctx.lineTo(s*0.05, s*0.2);
    ctx.moveTo(s*0.25, s*0.2);
    ctx.lineTo(0, -s*0.6);
    ctx.lineTo(-s*0.05, s*0.2);
    ctx.fill();

    ctx.fillStyle = '#666';
    ctx.beginPath();
    ctx.arc(0, 0, s*0.05, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  } else if (type === 3) { // Pipe
    ctx.fillStyle = COLORS.pipe;
    ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
    ctx.fillStyle = COLORS.pipeDark;
    ctx.fillRect(x + TILE_SIZE*0.1, y, TILE_SIZE*0.2, TILE_SIZE);
  }
}

function drawEnemy(ctx, x, y, frame) {
  const w = TILE_SIZE;
  const h = TILE_SIZE;

  ctx.fillStyle = '#8B4513';

  ctx.beginPath();
  ctx.arc(x + w/2, y + h/2, w/2, 0, Math.PI, true);
  ctx.fill();

  ctx.fillStyle = '#CD853F';
  ctx.fillRect(x + w*0.3, y + h/2, w*0.4, h/2);

  ctx.fillStyle = '#FFF';
  ctx.beginPath();
  ctx.arc(x + w*0.4, y + h*0.6, w*0.1, 0, Math.PI*2);
  ctx.arc(x + w*0.6, y + h*0.6, w*0.1, 0, Math.PI*2);
  ctx.fill();

  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.arc(x + w*0.42, y + h*0.6, w*0.04, 0, Math.PI*2);
  ctx.arc(x + w*0.62, y + h*0.6, w*0.04, 0, Math.PI*2);
  ctx.fill();

  if (Math.floor(frame / 10) % 2 === 0) {
    ctx.clearRect(x, y + h - 2, w, 2);
  }
}

function drawBackground(ctx) {
  ctx.fillStyle = COLORS.sky;
  ctx.fillRect(0, 0, view.w, view.h);

  ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';

  const cloud = (cx, cy, s) => {
    ctx.beginPath();
    ctx.arc(cx, cy, 30 * s, 0, Math.PI * 2);
    ctx.arc(cx + 40 * s, cy + 10 * s, 40 * s, 0, Math.PI * 2);
    ctx.arc(cx - 40 * s, cy + 10 * s, 40 * s, 0, Math.PI * 2);
    ctx.fill();
  };

  const offset = gameState.cameraX * 0.2;
  const w = view.w + 400;

  for(let i = 0; i < 3; i++) {
    let x = (200 + i * 500 - offset) % w;
    if (x < -200) x += w;
    cloud(x, 150 + (i%2)*50, 1.0 + (i%2)*0.2);
  }
}

/**
 * Game Logic
 */
class Level {
  constructor() {
    this.map = {};
    this.enemies = [];
    this.generatedX = 0;
    this.groundY = 10;
    this.gapCooldown = 0;
    this.gapRemaining = 0;

    // åˆå›ç”Ÿæˆç¯„å›²ã‚’åºƒãå–ã‚‹ï¼ˆç”»é¢å¹…ã®3å€ï¼‰
    this.updateMap(view.w * 3);
  }

  updateMap(targetX) {
    // å…ˆèª­ã¿ç¯„å›²ã‚’åºƒã‚ã« (+50)
    const targetTileX = Math.ceil(targetX / TILE_SIZE) + 50;

    // ç”Ÿæˆ
    while (this.generatedX < targetTileX) {
      this.generateColumn(this.generatedX);
      this.generatedX++;
    }

    // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    const deleteThreshold = Math.floor((gameState.cameraX - view.w) / TILE_SIZE);
    this.enemies = this.enemies.filter(e => e.x > gameState.cameraX - view.w);

    // å¤ã„ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã®å‰Šé™¤ï¼ˆè»½é‡åŒ–ï¼‰
    if (this.generatedX % 100 === 0) {
      for (let x in this.map) {
        if (parseInt(x) < deleteThreshold) {
          delete this.map[x];
        }
      }
    }
  }

  generateColumn(x) {
    this.map[x] = [];
    // åˆæœŸåŒ–: å…¨ã¦ã‚’0(ç©ºæ°—)ã«ã™ã‚‹
    for(let y=0; y<ROWS; y++) this.map[x][y] = 0;

    // ã‚¹ã‚¿ãƒ¼ãƒˆåœ°ç‚¹ã€œå®‰å…¨åœ
    if (x < 30) {
      for(let y=this.groundY; y<ROWS; y++) this.map[x][y] = 1;
      return;
    }

    // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³å‡¦ç†ï¼ˆç©´ã®ç›´å¾Œï¼‰
    if (this.gapCooldown > 0) {
      this.gapCooldown--;
      for(let y=this.groundY; y<ROWS; y++) this.map[x][y] = 1;

      // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ä¸­ã‚‚ã‚¢ã‚¤ãƒ†ãƒ ç­‰ã¯å‡ºã—ã¦OK
      this.generateObjects(x, this.groundY);
      return;
    }

    // æ–°ã—ã„ç©´ã®ç”Ÿæˆåˆ¤å®š
    if (this.gapRemaining <= 0 && Math.random() < 0.1) {
      const gapWidth = Math.floor(Math.random() * 2) + 2; // 2~3ãƒã‚¹
      this.gapRemaining = gapWidth;
      this.gapCooldown = gapWidth + 5; // ã‚¸ãƒ£ãƒ³ãƒ—å¾Œç€åœ°ã‚¹ãƒšãƒ¼ã‚¹ç¢ºä¿

      // ç©´ã®å‘ã“ã†å´ã®é«˜ã•ã‚’ã“ã“ã§æ±ºã‚ã¦ãŠã
      if (Math.random() < 0.5) {
        const diff = Math.floor(Math.random() * 3) - 1;
        this.groundY += diff;
        this.groundY = Math.max(7, Math.min(13, this.groundY));
      }
    }

    // ç©´ç”Ÿæˆä¸­
    if (this.gapRemaining > 0) {
      this.gapRemaining--;
      return; // åœ°é¢ç”Ÿæˆã—ãªã„
    }

    // åœ°é¢ã®é«˜ã•ã‚’ãŸã¾ã«å¤‰ãˆã‚‹
    if (Math.random() < 0.05) {
      this.groundY += Math.random() > 0.5 ? 1 : -1;
      this.groundY = Math.max(7, Math.min(13, this.groundY));
    }

    // åœ°é¢ç”Ÿæˆ
    for(let y=this.groundY; y<ROWS; y++) this.map[x][y] = 1;

    // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆé…ç½®
    this.generateObjects(x, this.groundY);
  }

  generateObjects(x, groundY) {
    if (Math.random() < 0.05) {
      // åœ°ä¸Šã®éšœå®³ç‰©
      this.map[x][groundY-1] = Math.random() > 0.5 ? 3 : 2;
    } else if (Math.random() < 0.05) {
      // ç©ºä¸­ã®è¶³å ´
      this.map[x][groundY-4] = 2;
    }

    // æ•µ
    if (Math.random() < 0.03) {
      this.enemies.push({
        x: x * TILE_SIZE,
        y: (groundY - 1) * TILE_SIZE,
        active: true
      });
    }
  }

  draw(ctx, frame) {
    const startCol = Math.floor(gameState.cameraX / TILE_SIZE);
    // æç”»ç¯„å›²ã‚’å°‘ã—åºƒã‚ã«å–ã‚‹ï¼ˆãƒãƒ©ã¤ãé˜²æ­¢ï¼‰
    const endCol = startCol + Math.ceil(view.w / TILE_SIZE) + 4;

    for (let x = startCol; x < endCol; x++) {
      if (!this.map[x]) continue;
      for (let y = 0; y < ROWS; y++) {
        const type = this.map[x][y];
        if (type && type !== 0) {
          drawBlock(ctx, x * TILE_SIZE - gameState.cameraX, y * TILE_SIZE, type);
        }
      }
    }

    this.enemies.forEach(e => {
      if (e.active && e.x > gameState.cameraX - TILE_SIZE && e.x < gameState.cameraX + view.w) {
        drawEnemy(ctx, e.x - gameState.cameraX, e.y, frame);
      }
    });
  }

  isSolid(x, y) {
    if (x < 0) return true;
    if (!this.map[x]) return false;
    if (y < 0 || y >= ROWS) return false;
    return this.map[x][y] !== undefined && this.map[x][y] !== 0;
  }
}

let player = {
  x: 0, y: 0, vx: 0, vy: 0, w: 0, h: 0, grounded: false, dead: false
};

let level;
let animationId;
let frameCount = 0;

function init() {
  // ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚: ã“ã“ã§ç”»é¢ã‚µã‚¤ã‚ºã«åˆã‚ã›ã¦å®šæ•°ã‚’ç¢ºå®šã•ã›ã‚‹
  resize();
  calculateConstants();

  player.w = TILE_SIZE * 0.9;
  player.h = TILE_SIZE * 1.5;
  player.x = TILE_SIZE * 4;
  player.y = TILE_SIZE * 5;
  player.vx = MOVE_SPEED;
  player.vy = 0;
  player.dead = false;

  level = new Level();
  gameState.score = 0;
  gameState.distance = 0;
  gameState.cameraX = 0;
  gameState.isRunning = true;
  jumpPressed = false;

  document.getElementById('start-screen').style.display = 'none';

  gameLoop();
}

function updatePhysics() {
  if (player.dead) {
    player.vy += GRAVITY;
    player.y += player.vy;
    return;
  }

  // ãƒãƒƒãƒ—æ›´æ–°: ç”»é¢å¤–ã‚‚ä½™è£•ã‚’æŒã£ã¦ç”Ÿæˆ
  level.updateMap(player.x + view.w);

  player.vx = MOVE_SPEED;

  if (jumpPressed && player.grounded) {
    player.vy = JUMP_FORCE;
    player.grounded = false;
    jumpPressed = false;
  }

  player.vy += GRAVITY;
  player.x += player.vx;
  player.y += player.vy;

  gameState.distance = Math.floor(player.x / TILE_SIZE);
  document.getElementById('dist').innerText = `${gameState.distance}`;

  player.grounded = false;

  const getTile = (px, py) => ({
    x: Math.floor(px / TILE_SIZE),
    y: Math.floor(py / TILE_SIZE)
  });

  // æ¥åœ°åˆ¤å®š
  if (player.vy >= 0) {
    const bl = getTile(player.x + 5, player.y + player.h);
    const br = getTile(player.x + player.w - 5, player.y + player.h);

    if (level.isSolid(bl.x, bl.y) || level.isSolid(br.x, br.y)) {
      const blockTop = bl.y * TILE_SIZE;
      if (player.y + player.h <= blockTop + player.vy + TILE_SIZE/2) {
        player.y = blockTop - player.h;
        player.vy = 0;
        player.grounded = true;
      }
    }
  } else {
    const tl = getTile(player.x + 5, player.y);
    const tr = getTile(player.x + player.w - 5, player.y);
    if (level.isSolid(tl.x, tl.y) || level.isSolid(tr.x, tr.y)) {
      player.y = (tl.y + 1) * TILE_SIZE;
      player.vy = 0;
    }
  }

  // è¡çªåˆ¤å®šï¼ˆå³å´ï¼‰
  const tr = getTile(player.x + player.w, player.y + 5);
  const br = getTile(player.x + player.w, player.y + player.h - 5);

  const checkHit = (tile) => {
    if (level.isSolid(tile.x, tile.y)) {
      if (!level.map[tile.x]) return true; // å®‰å…¨ç­–
      const type = level.map[tile.x][tile.y];

      if (type === 2) {
        level.map[tile.x][tile.y] = 0;
        gameState.score += 50;
        document.getElementById('score').innerText = `SCORE: ${gameState.score}`;
        return false;
      }
      return true;
    }
    return false;
  };

  const hitTop = checkHit(tr);
  const hitBottom = checkHit(br);

  if (hitTop || hitBottom) {
    die();
  }

  // è½ä¸‹æ­»
  if (player.y > view.h + 100) die();

  // ã‚«ãƒ¡ãƒ©è¿½å¾“
  const targetCamX = player.x - view.w * 0.2;
  gameState.cameraX = targetCamX;
  if (gameState.cameraX < 0) gameState.cameraX = 0;

  // æ•µã¨ã®å½“ãŸã‚Šåˆ¤å®š
  level.enemies.forEach(e => {
    if(!e.active) return;

    if (player.x < e.x + TILE_SIZE &&
        player.x + player.w > e.x &&
        player.y < e.y + TILE_SIZE &&
        player.y + player.h > e.y) {

      if (player.vy > 0 && player.y + player.h < e.y + TILE_SIZE * 0.6) {
        e.active = false;
        player.vy = JUMP_FORCE * 0.6;
        gameState.score += 100;
        document.getElementById('score').innerText = `SCORE: ${gameState.score}`;
      } else {
        die();
      }
    }
  });
}

function die() {
  if(player.dead) return;

  player.dead = true;
  player.vy = JUMP_FORCE;

  setTimeout(() => {
    gameState.isRunning = false;
    document.querySelector('#start-screen h1').innerText = "GAME OVER";
    document.querySelector('#start-btn').innerText = "TRY AGAIN";
    document.getElementById('start-screen').style.display = 'flex';
  }, 1500);
}

function gameLoop() {
  if (!gameState.isRunning) return;

  ctx.clearRect(0, 0, view.w, view.h);

  drawBackground(ctx);
  updatePhysics();
  level.draw(ctx, frameCount);
  drawPlayer(ctx, player.x - gameState.cameraX, player.y, frameCount);

  frameCount++;
  animationId = requestAnimationFrame(gameLoop);
}

// ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆ: ã‚¯ãƒªãƒƒã‚¯ã¨ã‚¿ãƒƒãƒä¸¡æ–¹ã«å¯¾å¿œ
const startBtn = document.getElementById('start-btn');
startBtn.addEventListener('click', (e) => { e.preventDefault(); init(); });
startBtn.addEventListener('touchstart', (e) => { e.preventDefault(); init(); });

const container = document.getElementById('game-container');
const handleInput = (e) => {
  if(!gameState.isRunning) return;
  if(e.type !== 'mousedown') e.preventDefault(); // ã‚¿ãƒƒãƒæ™‚ã®é‡è¤‡ã‚¤ãƒ™ãƒ³ãƒˆé˜²æ­¢
  jumpPressed = true;
};
container.addEventListener('touchstart', handleInput, {passive: false});
container.addEventListener('mousedown', handleInput);

window.addEventListener('keydown', e => {
  if(e.code === 'Space' || e.key === 'ArrowUp') handleInput(e);
});
window.addEventListener('keyup', e => {
  if(e.code === 'Space' || e.key === 'ArrowUp') jumpPressed = false;
});

container.addEventListener('touchend', () => jumpPressed = false);
container.addEventListener('mouseup', () => jumpPressed = false);
</script>
</body>
</html>