<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Modern Platformer Runner</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@700&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            font-family: 'M PLUS Rounded 1c', sans-serif;
            touch-action: none;
            width: 100vw;
            height: 100vh;
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlay - æœ€åˆã®ãƒ‡ã‚¶ã‚¤ãƒ³ã‚’ç¶­æŒ */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud {
            padding: 24px 32px;
            color: #333;
            font-weight: bold;
            font-size: 18px;
            display: flex;
            justify-content: space-between;
            z-index: 5;
        }

        .hud span {
            background: rgba(255, 255, 255, 0.6);
            padding: 8px 16px;
            border-radius: 20px;
            backdrop-filter: blur(4px);
        }

        /* Start Screen - æœ€åˆã®ãƒ‡ã‚¶ã‚¤ãƒ³ã‚’ç¶­æŒ */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 240, 245, 0.9);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #333;
            z-index: 10;
            pointer-events: auto;
        }

        h1 {
            font-size: 32px;
            margin-bottom: 40px;
            color: #333;
            letter-spacing: 2px;
        }

        .instruction-box {
            display: flex;
            gap: 20px;
            margin-bottom: 40px;
        }

        .instruction-item {
            background: white;
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            text-align: center;
            width: 120px;
        }

        .icon {
            font-size: 32px;
            margin-bottom: 10px;
            display: block;
        }

        .label {
            font-size: 12px;
            color: #666;
            font-weight: bold;
        }

        .start-btn {
            padding: 18px 60px;
            font-size: 18px;
            font-weight: bold;
            background: #333;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 50px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
            transition: transform 0.2s, box-shadow 0.2s;
            font-family: inherit;
        }

        .start-btn:active {
            transform: scale(0.95);
            box-shadow: 0 5px 10px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div class="hud">
            <span id="score">SCORE: 0</span>
            <span id="dist">DIST: 0m</span>
        </div>
    </div>

    <div id="start-screen">
        <h1>RUN & JUMP</h1>
        
        <div class="instruction-box">
            <div class="instruction-item">
                <span class="icon">ğŸ‘†</span>
                <span class="label">TAP TO JUMP</span>
            </div>
        </div>

        <button class="start-btn" id="start-btn">PLAY GAME</button>
    </div>
</div>

<script>
/**
 * Game Setup
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Colors - æœ€åˆã®ãƒ‡ã‚¶ã‚¤ãƒ³ã«æˆ»ã—ã¾ã—ãŸ
const COLORS = {
    sky: '#FFD9E6',       // è–„ã‚ã®ãƒ”ãƒ³ã‚¯
    ground: '#D4B856',    // è½ã¡ç€ã„ãŸé»„è‰²
    groundDark: '#B89C40',
    blockQ: '#FFB347',
    pipe: '#FF69B4',      // ãƒ”ãƒ³ã‚¯ã®åœŸç®¡
    pipeDark: '#C71585',
    text: '#333333'
};

// Game Configuration
let TILE_SIZE = 40;
let GRAVITY = 0.6;
let JUMP_FORCE = -12;
let MOVE_SPEED = 6; // ã‚ªãƒ¼ãƒˆãƒ©ãƒ³ç”¨ã®é€Ÿåº¦

// Game State
let gameState = {
    isRunning: false,
    score: 0,
    distance: 0,
    cameraX: 0
};

// Inputs
let jumpPressed = false;

/**
 * Resize & Responsive Layout
 */
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    TILE_SIZE = Math.ceil(canvas.height / 12);
    
    GRAVITY = TILE_SIZE * 0.03;
    JUMP_FORCE = -(TILE_SIZE * 0.55); // å°‘ã—ã‚¸ãƒ£ãƒ³ãƒ—åŠ›ã‚¢ãƒƒãƒ—
    MOVE_SPEED = TILE_SIZE * 0.15;
}
window.addEventListener('resize', resize);
resize();

/**
 * Drawing Functions - æœ€åˆã®ãƒ‡ã‚¶ã‚¤ãƒ³ã«æˆ»ã—ã¾ã—ãŸ
 */

function drawPlayer(ctx, x, y, frame) {
    const w = TILE_SIZE * 0.9;
    const h = TILE_SIZE * 1.5;
    
    ctx.save();
    ctx.translate(x, y);

    const ps = w / 12; // Pixel Size unit

    // Colors
    const c = {
        hair: '#222',
        skin: '#FCD',
        vest: '#2C3E50',
        shirt: '#FFF',
        pants: '#2C3E50'
    };

    // ã‚ªãƒ¼ãƒˆãƒ©ãƒ³ãªã®ã§å¸¸ã«èµ°ã£ã¦ã„ã‚‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
    // ãƒ•ãƒ¬ãƒ¼ãƒ ã”ã¨ã«è¶³ã‚’å‹•ã‹ã™
    const runFrame = Math.floor(frame / 5) % 4; 
    let legOffsetL = 0;
    let legOffsetR = 0;

    if (!player.grounded) {
        // ã‚¸ãƒ£ãƒ³ãƒ—ä¸­
        legOffsetL = -1;
        legOffsetR = -2;
    } else {
        // èµ°ã‚Š
        if (runFrame === 0) { legOffsetL = 0; legOffsetR = 0; }
        else if (runFrame === 1) { legOffsetL = -1; legOffsetR = 1; }
        else if (runFrame === 2) { legOffsetL = 0; legOffsetR = 0; }
        else { legOffsetL = 1; legOffsetR = -1; }
    }

    // --- é«ªã®æ¯›ï¼ˆæœ€åˆã®ãƒ‡ã‚¶ã‚¤ãƒ³ï¼‰ ---
    ctx.fillStyle = c.hair;
    ctx.fillRect(ps*2, ps*1, ps*8, ps*10); 
    ctx.fillRect(ps*1, ps*3, ps*1, ps*8); 
    
    // è¶³ (Animated)
    ctx.fillStyle = c.pants;
    // Left Leg
    ctx.fillRect(ps*3, ps*11 + legOffsetL * ps, ps*2, ps*4); 
    // Right Leg
    ctx.fillRect(ps*7, ps*11 + legOffsetR * ps, ps*2, ps*4);

    // Body (Vest)
    ctx.fillStyle = c.vest;
    ctx.fillRect(ps*3, ps*5, ps*6, ps*6);

    // Arms/Shirt
    ctx.fillStyle = c.shirt;
    ctx.fillRect(ps*5, ps*5, ps*2, ps*2); // V-neck
    // Arms swinging
    if(runFrame % 2 === 0 || !player.grounded) {
        ctx.fillRect(ps*2, ps*5, ps*1, ps*4); // L Arm
        ctx.fillRect(ps*9, ps*5, ps*1, ps*4); // R Arm
    } else {
        ctx.fillRect(ps*2, ps*4, ps*1, ps*4); // L Arm raised
        ctx.fillRect(ps*9, ps*6, ps*1, ps*4); // R Arm lowered
    }

    // Hands
    ctx.fillStyle = c.skin;
    ctx.fillRect(ps*2, ps*9 + (runFrame%2===0?0:-ps), ps*1, ps*1);
    ctx.fillRect(ps*9, ps*9 + (runFrame%2===0?0:ps), ps*1, ps*1);

    // Face
    ctx.fillRect(ps*3, ps*1, ps*6, ps*4);

    // Hair Front
    ctx.fillStyle = c.hair;
    ctx.fillRect(ps*3, 0, ps*6, ps*1);
    ctx.fillRect(ps*3, ps*1, ps*1, ps*3);
    ctx.fillRect(ps*8, ps*1, ps*1, ps*3);
    ctx.fillRect(ps*3, ps*1, ps*2, ps*1); // Bangs L
    ctx.fillRect(ps*7, ps*1, ps*2, ps*1); // Bangs R

    // Face details
    ctx.fillStyle = '#000';
    ctx.fillRect(ps*4, ps*2, ps*1, ps*0.5); // Eye L
    ctx.fillRect(ps*7, ps*2, ps*1, ps*0.5); // Eye R
    ctx.fillRect(ps*5, ps*3.5, ps*2, ps*0.5); // Mouth

    ctx.restore();
}

function drawBlock(ctx, x, y, type) {
    if (type === 1) { // Ground (Yellow - æœ€åˆã®ãƒ‡ã‚¶ã‚¤ãƒ³)
        ctx.fillStyle = COLORS.ground;
        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
        ctx.fillStyle = COLORS.groundDark;
        ctx.fillRect(x, y + TILE_SIZE - 4, TILE_SIZE, 4); 
    } else if (type === 2) { // Lucky Block
        ctx.fillStyle = COLORS.blockQ;
        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
        ctx.fillStyle = '#FFF';
        ctx.font = `bold ${TILE_SIZE * 0.6}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.fillText('?', x + TILE_SIZE/2, y + TILE_SIZE * 0.7);
    } else if (type === 3) { // Pipe (Pink - æœ€åˆã®ãƒ‡ã‚¶ã‚¤ãƒ³)
        ctx.fillStyle = COLORS.pipe;
        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
        ctx.fillStyle = COLORS.pipeDark;
        ctx.fillRect(x + TILE_SIZE*0.1, y, TILE_SIZE*0.2, TILE_SIZE);
    }
}

function drawEnemy(ctx, x, y, frame) {
    // æœ€åˆã®ã‚­ãƒã‚³ãƒ‡ã‚¶ã‚¤ãƒ³
    const w = TILE_SIZE;
    const h = TILE_SIZE;
    
    ctx.fillStyle = '#8B4513';
    
    // Simple Mushroom Shape
    ctx.beginPath();
    ctx.arc(x + w/2, y + h/2, w/2, 0, Math.PI, true);
    ctx.fill();
    
    ctx.fillStyle = '#CD853F'; // Stem
    ctx.fillRect(x + w*0.3, y + h/2, w*0.4, h/2);

    // Eyes
    ctx.fillStyle = '#FFF';
    ctx.beginPath();
    ctx.arc(x + w*0.4, y + h*0.6, w*0.1, 0, Math.PI*2);
    ctx.arc(x + w*0.6, y + h*0.6, w*0.1, 0, Math.PI*2);
    ctx.fill();
    
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(x + w*0.42, y + h*0.6, w*0.04, 0, Math.PI*2);
    ctx.arc(x + w*0.62, y + h*0.6, w*0.04, 0, Math.PI*2);
    ctx.fill();

    if (Math.floor(frame / 10) % 2 === 0) {
        ctx.clearRect(x, y + h - 2, w, 2);
    }
}

function drawBackground(ctx) {
    // æœ€åˆã®ãƒ‡ã‚¶ã‚¤ãƒ³ï¼ˆãƒ”ãƒ³ã‚¯ã®ç©ºã¨ä¸¸ã„é›²ï¼‰
    ctx.fillStyle = COLORS.sky;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
    
    const cloud = (cx, cy, s) => {
        ctx.beginPath();
        ctx.arc(cx, cy, 30 * s, 0, Math.PI * 2);
        ctx.arc(cx + 40 * s, cy + 10 * s, 40 * s, 0, Math.PI * 2);
        ctx.arc(cx - 40 * s, cy + 10 * s, 40 * s, 0, Math.PI * 2);
        ctx.fill();
    };

    // ã‚ªãƒ¼ãƒˆãƒ©ãƒ³ç”¨ã«èƒŒæ™¯ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é€Ÿåº¦ã‚’èª¿æ•´
    const offset = gameState.cameraX * 0.2;
    const w = canvas.width + 400;
    
    // è¤‡æ•°ã®é›²ã‚’ãƒ«ãƒ¼ãƒ—ã•ã›ã‚‹
    for(let i = 0; i < 3; i++) {
        let x = (200 + i * 500 - offset) % w;
        if (x < -200) x += w;
        cloud(x, 100 + (i%2)*50, 1.0 + (i%2)*0.2);
    }
}

/**
 * Game Logic - ã‚ªãƒ¼ãƒˆãƒ©ãƒ³ä»•æ§˜
 */
class Level {
    constructor() {
        this.map = [];
        this.enemies = [];
        this.width = 1000; // é•·ã„ã‚³ãƒ¼ã‚¹
        this.height = 15;
        this.generate();
    }

    generate() {
        // Init
        for (let x = 0; x < this.width; x++) {
            this.map[x] = [];
            for (let y = 0; y < this.height; y++) {
                this.map[x][y] = 0;
            }
        }

        // ã‚ªãƒ¼ãƒˆãƒ©ãƒ³ç”¨ã®ãƒãƒƒãƒ—ç”Ÿæˆãƒ­ã‚¸ãƒƒã‚¯
        let groundY = 10;
        
        for (let x = 0; x < this.width; x++) {
            // ã‚¹ã‚¿ãƒ¼ãƒˆåœ°ç‚¹ã¯å®‰å…¨ã«
            if (x < 20) {
                for(let y=groundY; y<15; y++) this.map[x][y] = 1;
                continue;
            }

            // ç©´ (Gap)
            if (Math.random() < 0.1 && x % 15 !== 0) {
                x += Math.floor(Math.random() * 2) + 1; // 2-3ãƒã‚¹ã®ç©´
            } else {
                // åœ°é¢
                for(let y=groundY; y<15; y++) this.map[x][y] = 1;

                // éšœå®³ç‰© (Block/Pipe)
                if (Math.random() < 0.05) {
                    // åœ°ä¸Šã®éšœå®³ç‰©
                    this.map[x][groundY-1] = Math.random() > 0.5 ? 3 : 2; 
                } else if (Math.random() < 0.05) {
                    // ç©ºä¸­ã®è¶³å ´
                    this.map[x][groundY-4] = 2;
                    if(Math.random() > 0.5) this.map[x+1][groundY-4] = 2;
                }
                
                // æ•µé…ç½®
                if (Math.random() < 0.03) {
                    this.enemies.push({
                        x: x * TILE_SIZE,
                        y: (groundY - 1) * TILE_SIZE,
                        active: true
                    });
                }
            }
        }
    }

    draw(ctx, frame) {
        const startCol = Math.floor(gameState.cameraX / TILE_SIZE);
        const endCol = startCol + Math.ceil(canvas.width / TILE_SIZE) + 2;

        for (let x = startCol; x < endCol; x++) {
            if (!this.map[x]) continue;
            for (let y = 0; y < 15; y++) {
                const type = this.map[x][y];
                if (type !== 0) {
                    drawBlock(ctx, x * TILE_SIZE - gameState.cameraX, y * TILE_SIZE, type);
                }
            }
        }

        this.enemies.forEach(e => {
            if (e.active && e.x > gameState.cameraX - TILE_SIZE && e.x < gameState.cameraX + canvas.width) {
                drawEnemy(ctx, e.x - gameState.cameraX, e.y, frame);
            }
        });
    }

    isSolid(x, y) {
        if (x < 0) return true; 
        if (x >= this.width) return false;
        if (y < 0 || y >= 15) return false;
        return this.map[x][y] !== 0;
    }
}

let player = {
    x: 0,
    y: 0,
    vx: 0,
    vy: 0,
    w: 0, 
    h: 0,
    grounded: false,
    dead: false
};

let level;
let animationId;
let frameCount = 0;

function init() {
    resize();
    player.w = TILE_SIZE * 0.9;
    player.h = TILE_SIZE * 1.5;
    player.x = TILE_SIZE * 4; // å°‘ã—å‰ç›®ã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆ
    player.y = TILE_SIZE * 5;
    player.vx = MOVE_SPEED; 
    player.vy = 0;
    player.dead = false;
    
    level = new Level();
    gameState.score = 0;
    gameState.distance = 0;
    gameState.cameraX = 0;
    gameState.isRunning = true;
    jumpPressed = false;

    document.getElementById('start-screen').style.display = 'none';
    
    gameLoop();
}

function updatePhysics() {
    if (player.dead) {
        player.vy += GRAVITY;
        player.y += player.vy;
        return;
    }

    // --- Auto Run Logic ---
    player.vx = MOVE_SPEED;

    // Jump
    if (jumpPressed && player.grounded) {
        player.vy = JUMP_FORCE;
        player.grounded = false;
        jumpPressed = false;
    }

    player.vy += GRAVITY;
    player.x += player.vx;
    player.y += player.vy;

    // Distance
    gameState.distance = Math.floor(player.x / TILE_SIZE);
    document.getElementById('dist').innerText = `DIST: ${gameState.distance}m`;

    player.grounded = false;
    
    const getTile = (px, py) => ({
        x: Math.floor(px / TILE_SIZE),
        y: Math.floor(py / TILE_SIZE)
    });

    // Vertical Collision
    if (player.vy >= 0) {
        const bl = getTile(player.x + 5, player.y + player.h);
        const br = getTile(player.x + player.w - 5, player.y + player.h);
        
        if (level.isSolid(bl.x, bl.y) || level.isSolid(br.x, br.y)) {
            const blockTop = bl.y * TILE_SIZE;
            if (player.y + player.h <= blockTop + player.vy + TILE_SIZE/2) {
                player.y = blockTop - player.h;
                player.vy = 0;
                player.grounded = true;
            }
        }
    } else {
        const tl = getTile(player.x + 5, player.y);
        const tr = getTile(player.x + player.w - 5, player.y);
        if (level.isSolid(tl.x, tl.y) || level.isSolid(tr.x, tr.y)) {
             player.y = (tl.y + 1) * TILE_SIZE;
             player.vy = 0;
        }
    }

    // Horizontal Collision (Walls -> Game Over)
    const tr = getTile(player.x + player.w, player.y + 5);
    const br = getTile(player.x + player.w, player.y + player.h - 5);
    
    if (level.isSolid(tr.x, tr.y) || level.isSolid(br.x, br.y)) {
        die();
    }

    if (player.y > canvas.height + 100) die();

    // Camera Logic
    const targetCamX = player.x - canvas.width * 0.2; // ç”»é¢ã®20%ã®ä½ç½®ã«å›ºå®š
    gameState.cameraX = targetCamX; 
    if (gameState.cameraX < 0) gameState.cameraX = 0;

    // Enemy Collision
    level.enemies.forEach(e => {
        if(!e.active) return;
        if (player.x < e.x + TILE_SIZE &&
            player.x + player.w > e.x &&
            player.y < e.y + TILE_SIZE &&
            player.y + player.h > e.y) {
            
            // è¸ã¿ã¤ã‘åˆ¤å®š
            if (player.vy > 0 && player.y + player.h < e.y + TILE_SIZE * 0.6) {
                e.active = false;
                player.vy = JUMP_FORCE * 0.6;
                gameState.score += 100;
                document.getElementById('score').innerText = `SCORE: ${gameState.score}`;
            } else {
                die();
            }
        }
    });
}

function die() {
    if(player.dead) return;
    player.dead = true;
    player.vy = JUMP_FORCE; 
    
    setTimeout(() => {
        gameState.isRunning = false;
        document.querySelector('#start-screen h1').innerText = "GAME OVER";
        document.querySelector('#start-btn').innerText = "TRY AGAIN";
        document.getElementById('start-screen').style.display = 'flex';
    }, 1500);
}

function gameLoop() {
    if (!gameState.isRunning) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    drawBackground(ctx);
    updatePhysics();
    level.draw(ctx, frameCount);
    
    // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼æç”»ï¼ˆå‘ãã¯å³å›ºå®šï¼‰
    drawPlayer(ctx, player.x - gameState.cameraX, player.y, frameCount);
    
    frameCount++;
    animationId = requestAnimationFrame(gameLoop);
}

/**
 * Event Listeners - ã‚¿ãƒƒãƒ—ã®ã¿ã®ã‚·ãƒ³ãƒ—ãƒ«æ“ä½œ
 */
document.getElementById('start-btn').addEventListener('click', init);

const container = document.getElementById('game-container');

const handleInput = (e) => {
    if(!gameState.isRunning) return;
    if(e.type !== 'mousedown') e.preventDefault();
    jumpPressed = true;
};

// Touch
container.addEventListener('touchstart', handleInput, {passive: false});

// Mouse / Keyboard
container.addEventListener('mousedown', handleInput);
window.addEventListener('keydown', e => {
    if(e.code === 'Space' || e.key === 'ArrowUp') handleInput(e);
});
window.addEventListener('keyup', e => {
    if(e.code === 'Space' || e.key === 'ArrowUp') jumpPressed = false;
});
container.addEventListener('touchend', () => jumpPressed = false);
container.addEventListener('mouseup', () => jumpPressed = false);

</script>
</body>
</html>